<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DAOS API: CART API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="daos_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DAOS API
   &#160;<span id="projectnumber">Latest</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group___c_a_r_t.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">CART API</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrt__corpc__ops.html">crt_corpc_ops</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga660a415dda17860766a23f515fa69964"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga660a415dda17860766a23f515fa69964">CRT_VAR</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga660a415dda17860766a23f515fa69964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fabc6807e06bc6464993a4f33d4d2f3"><td class="memItemLeft" align="right" valign="top"><a id="ga4fabc6807e06bc6464993a4f33d4d2f3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRT_PTR</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ga4fabc6807e06bc6464993a4f33d4d2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c6be89b4b895bd21e17dd88576d544b"><td class="memItemLeft" align="right" valign="top"><a id="ga0c6be89b4b895bd21e17dd88576d544b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRT_ARRAY</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ga0c6be89b4b895bd21e17dd88576d544b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ab1549db565fefa85fe10f6e8345d8b"><td class="memItemLeft" align="right" valign="top"><a id="ga4ab1549db565fefa85fe10f6e8345d8b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRT_RAW</b>&#160;&#160;&#160;3</td></tr>
<tr class="separator:ga4ab1549db565fefa85fe10f6e8345d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3a17507f6d6d79988f6800af7f0eaa2"><td class="memItemLeft" align="right" valign="top"><a id="gae3a17507f6d6d79988f6800af7f0eaa2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRT_GEN_GET_TYPE</b>(seq)&#160;&#160;&#160;BOOST_PP_SEQ_HEAD(seq)</td></tr>
<tr class="separator:gae3a17507f6d6d79988f6800af7f0eaa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35169dbf1608f11c205c294b10d9921e"><td class="memItemLeft" align="right" valign="top"><a id="ga35169dbf1608f11c205c294b10d9921e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRT_GEN_GET_NAME</b>(seq)&#160;&#160;&#160;BOOST_PP_SEQ_ELEM(1, seq)</td></tr>
<tr class="separator:ga35169dbf1608f11c205c294b10d9921e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46fbe994150ab8487414e5a838bffe90"><td class="memItemLeft" align="right" valign="top"><a id="ga46fbe994150ab8487414e5a838bffe90"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRT_GEN_GET_KIND</b>(seq)&#160;&#160;&#160;BOOST_PP_SEQ_TAIL(BOOST_PP_SEQ_TAIL(seq))</td></tr>
<tr class="separator:ga46fbe994150ab8487414e5a838bffe90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f57d141918ce10f867c1932687166e9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRT_GEN_STRUCT_FIELD</b>(r,  data,  seq)</td></tr>
<tr class="separator:ga7f57d141918ce10f867c1932687166e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2c6a8f789ef6e904a1dc1a89368c52a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRT_GEN_STRUCT</b>(struct_type_name,  seq)</td></tr>
<tr class="separator:gaf2c6a8f789ef6e904a1dc1a89368c52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga861a3ced53f5701d716737b48f986afb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>crt_proc_struct</b></td></tr>
<tr class="separator:ga861a3ced53f5701d716737b48f986afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c9b32fd34759489b509cd241396f6c7"><td class="memItemLeft" align="right" valign="top"><a id="ga5c9b32fd34759489b509cd241396f6c7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRT_GEN_X</b>(x)&#160;&#160;&#160;x</td></tr>
<tr class="separator:ga5c9b32fd34759489b509cd241396f6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62c6081cd624d7f624d0a307e5199ddf"><td class="memItemLeft" align="right" valign="top"><a id="ga62c6081cd624d7f624d0a307e5199ddf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRT_GEN_X2</b>(x)&#160;&#160;&#160;CRT_GEN_X BOOST_PP_LPAREN() crt_proc_##x BOOST_PP_RPAREN()</td></tr>
<tr class="separator:ga62c6081cd624d7f624d0a307e5199ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d9edb246dbd96ed7b8388c6cab241c3"><td class="memItemLeft" align="right" valign="top"><a id="ga5d9edb246dbd96ed7b8388c6cab241c3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRT_GEN_GET_FUNC</b>(seq)&#160;&#160;&#160;CRT_GEN_X2 BOOST_PP_SEQ_FIRST_N(1, seq)</td></tr>
<tr class="separator:ga5d9edb246dbd96ed7b8388c6cab241c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0168cde3accc04f90390feef63ce3d25"><td class="memItemLeft" align="right" valign="top"><a id="ga0168cde3accc04f90390feef63ce3d25"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRT_GEN_PROC_FIELD</b>(r,  ptr,  seq)</td></tr>
<tr class="separator:ga0168cde3accc04f90390feef63ce3d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8199b325289cd50bf713a97b51446255"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRT_GEN_PROC_FUNC</b>(type_name,  seq)</td></tr>
<tr class="separator:ga8199b325289cd50bf713a97b51446255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3875cc9d015cd8f5e18e63e06bea925"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRT_RPC_DECLARE</b>(rpc_name,  fields_in,  fields_out)</td></tr>
<tr class="separator:gaf3875cc9d015cd8f5e18e63e06bea925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga046876d498fadedaeb2fad557173880c"><td class="memItemLeft" align="right" valign="top"><a id="ga046876d498fadedaeb2fad557173880c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRT_DISABLE_SIZEOF_POINTER_DIV</b></td></tr>
<tr class="separator:ga046876d498fadedaeb2fad557173880c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62c11e872f6451559fe92b2e6482e274"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRT_RPC_DEFINE</b>(rpc_name,  fields_in,  fields_out)</td></tr>
<tr class="separator:ga62c11e872f6451559fe92b2e6482e274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdd1d9438cd8c92a81d65196651200ea"><td class="memItemLeft" align="right" valign="top"><a id="gacdd1d9438cd8c92a81d65196651200ea"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRT_RPC_CORPC_REGISTER</b>(opcode,  rpc_name,  rpc_handler,  co_ops)&#160;&#160;&#160;<a class="el" href="group___c_a_r_t.html#gaba82673fa83307e86afef3fc3fea3961">crt_corpc_register</a>(opcode, &amp;CQF_##rpc_name, rpc_handler, co_ops)</td></tr>
<tr class="separator:gacdd1d9438cd8c92a81d65196651200ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51d539c4a42ff336191f90826d1d6e0a"><td class="memItemLeft" align="right" valign="top"><a id="ga51d539c4a42ff336191f90826d1d6e0a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRT_RPC_SRV_REGISTER</b>(opcode,  flags,  rpc_name,  rpc_handler)&#160;&#160;&#160;<a class="el" href="group___c_a_r_t.html#ga836b16ede44ec086c47c6c0da5f3c67c">crt_rpc_srv_register</a>(opcode, flags, &amp;CQF_##rpc_name, rpc_handler)</td></tr>
<tr class="separator:ga51d539c4a42ff336191f90826d1d6e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7730764c66d341097cd274d1d58fa737"><td class="memItemLeft" align="right" valign="top"><a id="ga7730764c66d341097cd274d1d58fa737"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRT_RPC_REGISTER</b>(opcode,  flags,  rpc_name)&#160;&#160;&#160;<a class="el" href="group___c_a_r_t.html#ga13f295ad36554f93feee03e6fd76f789">crt_rpc_register</a>(opcode, flags, &amp;CQF_##rpc_name)</td></tr>
<tr class="separator:ga7730764c66d341097cd274d1d58fa737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aa8c8adbbe2ac33f3a1eebd040388c2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga7aa8c8adbbe2ac33f3a1eebd040388c2">crt_bulk_decref</a>(bulk_hdl)&#160;&#160;&#160;<a class="el" href="group___c_a_r_t.html#gac6dabec2240d728d62bacec3d2a89df7">crt_bulk_free</a>(bulk_hdl)</td></tr>
<tr class="separator:ga7aa8c8adbbe2ac33f3a1eebd040388c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5f69a6a113bf635cb5b25137982fc60"><td class="memItemLeft" align="right" valign="top"><a id="gaf5f69a6a113bf635cb5b25137982fc60"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRT_TREE_TYPE_SHIFT</b>&#160;&#160;&#160;(16U)</td></tr>
<tr class="separator:gaf5f69a6a113bf635cb5b25137982fc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bb95e351370f62d71e9b09534408fd6"><td class="memItemLeft" align="right" valign="top"><a id="ga5bb95e351370f62d71e9b09534408fd6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRT_TREE_MAX_RATIO</b>&#160;&#160;&#160;(64)</td></tr>
<tr class="separator:ga5bb95e351370f62d71e9b09534408fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga799c555309c4db527577a11349e73543"><td class="memItemLeft" align="right" valign="top"><a id="ga799c555309c4db527577a11349e73543"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRT_TREE_MIN_RATIO</b>&#160;&#160;&#160;(2)</td></tr>
<tr class="separator:ga799c555309c4db527577a11349e73543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ff3f3cd376d345d09b7418921233950"><td class="memItemLeft" align="right" valign="top"><a id="ga5ff3f3cd376d345d09b7418921233950"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>crt_proc_raw</b>&#160;&#160;&#160;<a class="el" href="group___c_a_r_t.html#gac68d7ff7120655c800ba09359640be50">crt_proc_memcpy</a></td></tr>
<tr class="separator:ga5ff3f3cd376d345d09b7418921233950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f0cf8025ae3cf6c0117ef0b61e32beb"><td class="memItemLeft" align="right" valign="top"><a id="ga6f0cf8025ae3cf6c0117ef0b61e32beb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>crt_proc__Bool</b>&#160;&#160;&#160;<a class="el" href="group___c_a_r_t.html#gaf7e7c9babd4f43f0a1ae0b96f1702c7d">crt_proc_bool</a></td></tr>
<tr class="separator:ga6f0cf8025ae3cf6c0117ef0b61e32beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga387956ae8a5f6e2007e553261aeaf539"><td class="memItemLeft" align="right" valign="top"><a id="ga387956ae8a5f6e2007e553261aeaf539"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>crt_proc_d_rank_t</b>&#160;&#160;&#160;<a class="el" href="group___c_a_r_t.html#ga26a21f8d43858142c598eee1387b12b7">crt_proc_uint32_t</a></td></tr>
<tr class="separator:ga387956ae8a5f6e2007e553261aeaf539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7463264b7ab151b91a6c5eee3b004182"><td class="memItemLeft" align="right" valign="top"><a id="ga7463264b7ab151b91a6c5eee3b004182"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>crt_proc_int</b>&#160;&#160;&#160;<a class="el" href="group___c_a_r_t.html#gaa95f26166658b049482d10e6fee8ff28">crt_proc_int32_t</a></td></tr>
<tr class="separator:ga7463264b7ab151b91a6c5eee3b004182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga262f77988bae2ef3115df1cd11dc95fd"><td class="memItemLeft" align="right" valign="top"><a id="ga262f77988bae2ef3115df1cd11dc95fd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>crt_proc_crt_status_t</b>&#160;&#160;&#160;<a class="el" href="group___c_a_r_t.html#gaa95f26166658b049482d10e6fee8ff28">crt_proc_int32_t</a></td></tr>
<tr class="separator:ga262f77988bae2ef3115df1cd11dc95fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c073826bf717f754242e719981142f4"><td class="memItemLeft" align="right" valign="top"><a id="ga7c073826bf717f754242e719981142f4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>crt_proc_crt_group_id_t</b>&#160;&#160;&#160;<a class="el" href="group___c_a_r_t.html#ga778f5628eab28dfe9650d7a0ea189394">crt_proc_d_string_t</a></td></tr>
<tr class="separator:ga7c073826bf717f754242e719981142f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf81b67195f89b983424d838e24e4473f"><td class="memItemLeft" align="right" valign="top"><a id="gaf81b67195f89b983424d838e24e4473f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>crt_proc_crt_phy_addr_t</b>&#160;&#160;&#160;<a class="el" href="group___c_a_r_t.html#ga778f5628eab28dfe9650d7a0ea189394">crt_proc_d_string_t</a></td></tr>
<tr class="separator:gaf81b67195f89b983424d838e24e4473f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gab814fd7c6d7030a7ff733c3180f3c426"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gab814fd7c6d7030a7ff733c3180f3c426">crt_rpc_task_t</a>) (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a> *ctx, void *rpc_hdlr_arg, void(*rpc_hdlr) (void *), void *arg)</td></tr>
<tr class="separator:gab814fd7c6d7030a7ff733c3180f3c426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19f6a8a70ca59be9a7eb596d2b998c4d"><td class="memItemLeft" align="right" valign="top"><a id="ga19f6a8a70ca59be9a7eb596d2b998c4d"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>crt_grp_destroy_cb_t</b>) (void *arg, int status)</td></tr>
<tr class="separator:ga19f6a8a70ca59be9a7eb596d2b998c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65671c60f0a8421ea337888f2c7f6362"><td class="memItemLeft" align="right" valign="top"><a id="ga65671c60f0a8421ea337888f2c7f6362"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>crt_progress_cb</b>) (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a> ctx, void *arg)</td></tr>
<tr class="separator:ga65671c60f0a8421ea337888f2c7f6362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98c70ff85a11e6b8bd2aea9b6e9659d8"><td class="memItemLeft" align="right" valign="top"><a id="ga98c70ff85a11e6b8bd2aea9b6e9659d8"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>crt_timeout_cb</b>) (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a> ctx, <a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga22c4380156baf0663b9d7eee1ae65004">crt_rpc_t</a> *rpc, void *arg)</td></tr>
<tr class="separator:ga98c70ff85a11e6b8bd2aea9b6e9659d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee8bbd2c1fc8670b2616b4d302368666"><td class="memItemLeft" align="right" valign="top"><a id="gaee8bbd2c1fc8670b2616b4d302368666"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>crt_eviction_cb</b>) (<a class="el" href="structcrt__group.html">crt_group_t</a> *grp, d_rank_t rank, void *arg)</td></tr>
<tr class="separator:gaee8bbd2c1fc8670b2616b4d302368666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd43636e1237f4e99c6425b5fab43564"><td class="memItemLeft" align="right" valign="top"><a id="gacd43636e1237f4e99c6425b5fab43564"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>crt_event_cb</b>) (d_rank_t rank, enum <a class="el" href="group___c_a_r_t.html#ga77aaf444cca8082606259c3cb873f142">crt_event_source</a> src, enum crt_event_type type, void *arg)</td></tr>
<tr class="separator:gacd43636e1237f4e99c6425b5fab43564"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gabbc9d44c874cc396db1f7500cf8d085e"><td class="memItemLeft" align="right" valign="top"><a id="gabbc9d44c874cc396db1f7500cf8d085e"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>crt_tree_type</b> { <br />
&#160;&#160;<b>CRT_TREE_INVALID</b> = 0, 
<b>CRT_TREE_MIN</b> = 1, 
<b>CRT_TREE_FLAT</b> = 1, 
<b>CRT_TREE_KARY</b> = 2, 
<br />
&#160;&#160;<b>CRT_TREE_KNOMIAL</b> = 3, 
<b>CRT_TREE_MAX</b> = 3
<br />
 }</td></tr>
<tr class="separator:gabbc9d44c874cc396db1f7500cf8d085e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfbc8243090b9821fcb4a138a205cb34"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gacfbc8243090b9821fcb4a138a205cb34">crt_proc_op_t</a> { <a class="el" href="group___c_a_r_t.html#ggacfbc8243090b9821fcb4a138a205cb34a356d2703575b63de86a40aa29cc4fbde">CRT_PROC_ENCODE</a>, 
<a class="el" href="group___c_a_r_t.html#ggacfbc8243090b9821fcb4a138a205cb34a1d32757630fc4bb27314f7ed495fc172">CRT_PROC_DECODE</a>, 
<a class="el" href="group___c_a_r_t.html#ggacfbc8243090b9821fcb4a138a205cb34a476f3ed609dd4936e15f34765bdb69ff">CRT_PROC_FREE</a>
 }</td></tr>
<tr class="separator:gacfbc8243090b9821fcb4a138a205cb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77aaf444cca8082606259c3cb873f142"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga77aaf444cca8082606259c3cb873f142">crt_event_source</a> { <a class="el" href="group___c_a_r_t.html#gga77aaf444cca8082606259c3cb873f142a1d3a451747b0335f4b51113d994196b6">CRT_EVS_UNKNOWN</a>, 
<a class="el" href="group___c_a_r_t.html#gga77aaf444cca8082606259c3cb873f142a665dd87be3339053386d96020e7b3cc9">CRT_EVS_SWIM</a>, 
<b>CRT_EVS_GRPMOD</b>
 }</td></tr>
<tr class="separator:ga77aaf444cca8082606259c3cb873f142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f63c91e081ffe734b4636ca366c1c41"><td class="memItemLeft" align="right" valign="top"><a id="ga7f63c91e081ffe734b4636ca366c1c41"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>crt_event_type</b> { <b>CRT_EVT_ALIVE</b>, 
<b>CRT_EVT_DEAD</b>
 }</td></tr>
<tr class="separator:ga7f63c91e081ffe734b4636ca366c1c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9383ec65a20b8de170a7e54c19ed135d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga9383ec65a20b8de170a7e54c19ed135d">crt_init_opt</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gade68a0764f3116705808a124b9147ab6">crt_group_id_t</a> grpid, uint32_t flags, <a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gab22231966be5442b49fdced962a513df">crt_init_options_t</a> *opt)</td></tr>
<tr class="separator:ga9383ec65a20b8de170a7e54c19ed135d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07eb1757b968c01796e32a5b9350cb8f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga07eb1757b968c01796e32a5b9350cb8f">crt_context_create</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a> *crt_ctx)</td></tr>
<tr class="separator:ga07eb1757b968c01796e32a5b9350cb8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c292fc8a9b62dca06eab39f6f598423"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga0c292fc8a9b62dca06eab39f6f598423">crt_context_set_timeout</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a> crt_ctx, uint32_t timeout_sec)</td></tr>
<tr class="separator:ga0c292fc8a9b62dca06eab39f6f598423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bbef2e88904b5ff96ac5e026727ebc3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga0bbef2e88904b5ff96ac5e026727ebc3">crt_context_destroy</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a> crt_ctx, int force)</td></tr>
<tr class="separator:ga0bbef2e88904b5ff96ac5e026727ebc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bbbd9ba3a54384b8c41470652d3f222"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga1bbbd9ba3a54384b8c41470652d3f222">crt_context_ep_empty</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a> crt_ctx)</td></tr>
<tr class="separator:ga1bbbd9ba3a54384b8c41470652d3f222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cd1507f48cd4c6e7a74def265859a5c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga8cd1507f48cd4c6e7a74def265859a5c">crt_context_flush</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a> crt_ctx, uint64_t timeout)</td></tr>
<tr class="separator:ga8cd1507f48cd4c6e7a74def265859a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaead25d94b1228f3a3c33b0a60a7b482f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gaead25d94b1228f3a3c33b0a60a7b482f">crt_context_idx</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a> crt_ctx, int *ctx_idx)</td></tr>
<tr class="separator:gaead25d94b1228f3a3c33b0a60a7b482f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fed553ebd62a4ff404b339cf3e2a5e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga4fed553ebd62a4ff404b339cf3e2a5e4">crt_context_num</a> (int *ctx_num)</td></tr>
<tr class="separator:ga4fed553ebd62a4ff404b339cf3e2a5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4586b6542b4c809a737a63e18b6f314"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gac4586b6542b4c809a737a63e18b6f314">crt_finalize</a> (void)</td></tr>
<tr class="separator:gac4586b6542b4c809a737a63e18b6f314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8e2ce33333c631754c0ea69846851d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gad8e2ce33333c631754c0ea69846851d8">crt_progress</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a> crt_ctx, int64_t timeout)</td></tr>
<tr class="separator:gad8e2ce33333c631754c0ea69846851d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7611702682ff56c57d697cb2670d426"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gab7611702682ff56c57d697cb2670d426">crt_progress_cond</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a> crt_ctx, int64_t timeout, <a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gacef78a24d5f55f2da8a57bb1aceef174">crt_progress_cond_cb_t</a> cond_cb, void *arg)</td></tr>
<tr class="separator:gab7611702682ff56c57d697cb2670d426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga620993c739a94ff703d78ce92a630c56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga620993c739a94ff703d78ce92a630c56">crt_req_create</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a> crt_ctx, <a class="el" href="structcrt__endpoint__t.html">crt_endpoint_t</a> *tgt_ep, <a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gae3dde8d6f8414e344befaafc0a3b7d3a">crt_opcode_t</a> opc, <a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga22c4380156baf0663b9d7eee1ae65004">crt_rpc_t</a> **req)</td></tr>
<tr class="separator:ga620993c739a94ff703d78ce92a630c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga709043318d2a089cb7f8816afbb08388"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga709043318d2a089cb7f8816afbb08388">crt_req_set_endpoint</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga22c4380156baf0663b9d7eee1ae65004">crt_rpc_t</a> *req, <a class="el" href="structcrt__endpoint__t.html">crt_endpoint_t</a> *tgt_ep)</td></tr>
<tr class="separator:ga709043318d2a089cb7f8816afbb08388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5613cf2c576e417c441f66416c0a816d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga5613cf2c576e417c441f66416c0a816d">crt_req_set_timeout</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga22c4380156baf0663b9d7eee1ae65004">crt_rpc_t</a> *req, uint32_t timeout_sec)</td></tr>
<tr class="separator:ga5613cf2c576e417c441f66416c0a816d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac57bcd14a37730e582e8e883cec02a34"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gac57bcd14a37730e582e8e883cec02a34">crt_req_addref</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga22c4380156baf0663b9d7eee1ae65004">crt_rpc_t</a> *req)</td></tr>
<tr class="separator:gac57bcd14a37730e582e8e883cec02a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadced98d9b4ff3084a36e4bc1034c28a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gadced98d9b4ff3084a36e4bc1034c28a8">crt_req_decref</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga22c4380156baf0663b9d7eee1ae65004">crt_rpc_t</a> *req)</td></tr>
<tr class="separator:gadced98d9b4ff3084a36e4bc1034c28a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfddf38953b180f44f8c4b53b9b57973"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gacfddf38953b180f44f8c4b53b9b57973">crt_req_send</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga22c4380156baf0663b9d7eee1ae65004">crt_rpc_t</a> *req, <a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaec5f68d3f953c61fadbd8a3d1a39c919">crt_cb_t</a> complete_cb, void *arg)</td></tr>
<tr class="separator:gacfddf38953b180f44f8c4b53b9b57973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d7216bc7c9cf01c3ca3ce41a1d52783"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga3d7216bc7c9cf01c3ca3ce41a1d52783">crt_reply_send</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga22c4380156baf0663b9d7eee1ae65004">crt_rpc_t</a> *req)</td></tr>
<tr class="separator:ga3d7216bc7c9cf01c3ca3ce41a1d52783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9abd7828b2b604fb68c34f5a4cf9568f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga9abd7828b2b604fb68c34f5a4cf9568f">crt_req_src_rank_get</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga22c4380156baf0663b9d7eee1ae65004">crt_rpc_t</a> *req, d_rank_t *rank)</td></tr>
<tr class="separator:ga9abd7828b2b604fb68c34f5a4cf9568f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77c47e976ee1a7b340d32c7ad6ee76d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga77c47e976ee1a7b340d32c7ad6ee76d3">crt_req_dst_rank_get</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga22c4380156baf0663b9d7eee1ae65004">crt_rpc_t</a> *req, d_rank_t *rank)</td></tr>
<tr class="separator:ga77c47e976ee1a7b340d32c7ad6ee76d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga367a527b8653b020fedfcb6314dd623f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga367a527b8653b020fedfcb6314dd623f">crt_req_dst_tag_get</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga22c4380156baf0663b9d7eee1ae65004">crt_rpc_t</a> *req, uint32_t *tag)</td></tr>
<tr class="separator:ga367a527b8653b020fedfcb6314dd623f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfaee37eaf074ffaab7a7706544935c5"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gadfaee37eaf074ffaab7a7706544935c5">crt_hlc_get</a> (void)</td></tr>
<tr class="separator:gadfaee37eaf074ffaab7a7706544935c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25030f5bcea43a1e47f56cf7f43cd596"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga25030f5bcea43a1e47f56cf7f43cd596">crt_hlc_get_msg</a> (uint64_t msg, uint64_t *hlc_out, uint64_t *offset)</td></tr>
<tr class="separator:ga25030f5bcea43a1e47f56cf7f43cd596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41358b9de3b91a0f453077886b64ea22"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga41358b9de3b91a0f453077886b64ea22">crt_hlc2nsec</a> (uint64_t hlc)</td></tr>
<tr class="separator:ga41358b9de3b91a0f453077886b64ea22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a895b8ea1fb5065547e963872a6ad5f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga4a895b8ea1fb5065547e963872a6ad5f">crt_nsec2hlc</a> (uint64_t nsec)</td></tr>
<tr class="separator:ga4a895b8ea1fb5065547e963872a6ad5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dcbf9c1b804b281539c8d14884e9f2e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga0dcbf9c1b804b281539c8d14884e9f2e">crt_hlc2unixnsec</a> (uint64_t hlc)</td></tr>
<tr class="separator:ga0dcbf9c1b804b281539c8d14884e9f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga100933432920bca56a6c1f51e9b1d35d"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga100933432920bca56a6c1f51e9b1d35d">crt_unixnsec2hlc</a> (uint64_t unixnsec)</td></tr>
<tr class="separator:ga100933432920bca56a6c1f51e9b1d35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2737d6daf6a8ad986097ff85fc8736a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga2737d6daf6a8ad986097ff85fc8736a6">crt_hlc_epsilon_set</a> (uint64_t epsilon)</td></tr>
<tr class="separator:ga2737d6daf6a8ad986097ff85fc8736a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga154ce95ef86a6ded2d1470dbbbc87131"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga154ce95ef86a6ded2d1470dbbbc87131">crt_hlc_epsilon_get</a> (void)</td></tr>
<tr class="separator:ga154ce95ef86a6ded2d1470dbbbc87131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6e9725c387d76d22a7f6b7a99d5d601"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gac6e9725c387d76d22a7f6b7a99d5d601">crt_hlc_epsilon_get_bound</a> (uint64_t hlc)</td></tr>
<tr class="separator:gac6e9725c387d76d22a7f6b7a99d5d601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3061431302513c2fc6b37b0844eebfb0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga3061431302513c2fc6b37b0844eebfb0">crt_req_abort</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga22c4380156baf0663b9d7eee1ae65004">crt_rpc_t</a> *req)</td></tr>
<tr class="separator:ga3061431302513c2fc6b37b0844eebfb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga896d0246d32f5e9edc4572fdd90fdf79"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga896d0246d32f5e9edc4572fdd90fdf79">crt_rank_abort</a> (d_rank_t rank)</td></tr>
<tr class="separator:ga896d0246d32f5e9edc4572fdd90fdf79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga076fbaa744c9de3126d40e67e32d44c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga076fbaa744c9de3126d40e67e32d44c4">crt_rank_abort_all</a> (<a class="el" href="structcrt__group.html">crt_group_t</a> *grp)</td></tr>
<tr class="separator:ga076fbaa744c9de3126d40e67e32d44c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab49687fc6b749807872c6c14f6dbf7ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gab49687fc6b749807872c6c14f6dbf7ab">crt_ep_abort</a> (<a class="el" href="structcrt__endpoint__t.html">crt_endpoint_t</a> *ep)</td></tr>
<tr class="separator:gab49687fc6b749807872c6c14f6dbf7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13f295ad36554f93feee03e6fd76f789"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga13f295ad36554f93feee03e6fd76f789">crt_rpc_register</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gae3dde8d6f8414e344befaafc0a3b7d3a">crt_opcode_t</a> opc, uint32_t flags, struct <a class="el" href="structcrt__req__format.html">crt_req_format</a> *drf)</td></tr>
<tr class="separator:ga13f295ad36554f93feee03e6fd76f789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga383347752c15c431a5eabedafc2d2910"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga383347752c15c431a5eabedafc2d2910">crt_context_register_rpc_task</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a> crt_ctx, <a class="el" href="group___c_a_r_t.html#gab814fd7c6d7030a7ff733c3180f3c426">crt_rpc_task_t</a> rpc_cb, <a class="el" href="group___c_a_r_t.html#gab814fd7c6d7030a7ff733c3180f3c426">crt_rpc_task_t</a> iv_resp_cb, void *arg)</td></tr>
<tr class="separator:ga383347752c15c431a5eabedafc2d2910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga836b16ede44ec086c47c6c0da5f3c67c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga836b16ede44ec086c47c6c0da5f3c67c">crt_rpc_srv_register</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gae3dde8d6f8414e344befaafc0a3b7d3a">crt_opcode_t</a> opc, uint32_t flags, struct <a class="el" href="structcrt__req__format.html">crt_req_format</a> *crf, <a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga163a4cfb0f83c051338adb9a4c326eed">crt_rpc_cb_t</a> rpc_handler)</td></tr>
<tr class="separator:ga836b16ede44ec086c47c6c0da5f3c67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba8a38409ed5a85ae321b6824dafa2a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gaba8a38409ed5a85ae321b6824dafa2a4">crt_bulk_create</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a> crt_ctx, d_sg_list_t *sgl, <a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga0baa03079c26075653589c9138e74e0e">crt_bulk_perm_t</a> bulk_perm, <a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga98854df58311faf6d4fcfb3c7554f66c">crt_bulk_t</a> *bulk_hdl)</td></tr>
<tr class="separator:gaba8a38409ed5a85ae321b6824dafa2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac66777b15f7a835cf8806ff91199b0fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gac66777b15f7a835cf8806ff91199b0fa">crt_bulk_bind</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga98854df58311faf6d4fcfb3c7554f66c">crt_bulk_t</a> bulk_hdl, <a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a> crt_ctx)</td></tr>
<tr class="separator:gac66777b15f7a835cf8806ff91199b0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71778dc6e151ae5cb915e251a94053f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga71778dc6e151ae5cb915e251a94053f0">crt_bulk_addref</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga98854df58311faf6d4fcfb3c7554f66c">crt_bulk_t</a> bulk_hdl)</td></tr>
<tr class="separator:ga71778dc6e151ae5cb915e251a94053f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62bfa2cc197157396a2d9a27bd85503a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga62bfa2cc197157396a2d9a27bd85503a">crt_bulk_access</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga98854df58311faf6d4fcfb3c7554f66c">crt_bulk_t</a> bulk_hdl, d_sg_list_t *sgl)</td></tr>
<tr class="separator:ga62bfa2cc197157396a2d9a27bd85503a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6dabec2240d728d62bacec3d2a89df7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gac6dabec2240d728d62bacec3d2a89df7">crt_bulk_free</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga98854df58311faf6d4fcfb3c7554f66c">crt_bulk_t</a> bulk_hdl)</td></tr>
<tr class="separator:gac6dabec2240d728d62bacec3d2a89df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae90d605eafc12f8c90e7aa430b87679"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gaae90d605eafc12f8c90e7aa430b87679">crt_bulk_transfer</a> (struct <a class="el" href="structcrt__bulk__desc.html">crt_bulk_desc</a> *bulk_desc, <a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf25e76b2c5b895478f2b640af5ef9405">crt_bulk_cb_t</a> complete_cb, void *arg, crt_bulk_opid_t *opid)</td></tr>
<tr class="separator:gaae90d605eafc12f8c90e7aa430b87679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga219734f8633dcbe40254e7586f9ff810"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga219734f8633dcbe40254e7586f9ff810">crt_bulk_bind_transfer</a> (struct <a class="el" href="structcrt__bulk__desc.html">crt_bulk_desc</a> *bulk_desc, <a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf25e76b2c5b895478f2b640af5ef9405">crt_bulk_cb_t</a> complete_cb, void *arg, crt_bulk_opid_t *opid)</td></tr>
<tr class="separator:ga219734f8633dcbe40254e7586f9ff810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ad87ffb793d7e1ada6a9c2a2a9faaa2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga8ad87ffb793d7e1ada6a9c2a2a9faaa2">crt_bulk_get_len</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga98854df58311faf6d4fcfb3c7554f66c">crt_bulk_t</a> bulk_hdl, size_t *bulk_len)</td></tr>
<tr class="separator:ga8ad87ffb793d7e1ada6a9c2a2a9faaa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad009bd02a5e2bc06d63e35fb87dfadc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gaad009bd02a5e2bc06d63e35fb87dfadc">crt_bulk_get_sgnum</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga98854df58311faf6d4fcfb3c7554f66c">crt_bulk_t</a> bulk_hdl, unsigned int *bulk_sgnum)</td></tr>
<tr class="separator:gaad009bd02a5e2bc06d63e35fb87dfadc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1b44d6b294d89a75744fd7262cf96d8"><td class="memItemLeft" align="right" valign="top"><a id="gae1b44d6b294d89a75744fd7262cf96d8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>crt_bulk_abort</b> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a> crt_ctx, crt_bulk_opid_t opid)</td></tr>
<tr class="separator:gae1b44d6b294d89a75744fd7262cf96d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga924c5e73f8133fadc6d323eb7ec596ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcrt__group.html">crt_group_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga924c5e73f8133fadc6d323eb7ec596ac">crt_group_lookup</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gade68a0764f3116705808a124b9147ab6">crt_group_id_t</a> grp_id)</td></tr>
<tr class="separator:ga924c5e73f8133fadc6d323eb7ec596ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89eb388dcb9f8e29d4aaa3f10aec0dd8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga89eb388dcb9f8e29d4aaa3f10aec0dd8">crt_group_destroy</a> (<a class="el" href="structcrt__group.html">crt_group_t</a> *grp, crt_grp_destroy_cb_t grp_destroy_cb, void *arg)</td></tr>
<tr class="separator:ga89eb388dcb9f8e29d4aaa3f10aec0dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69f78261760cc22432b6d79f591ef6f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga69f78261760cc22432b6d79f591ef6f6">crt_group_attach</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gade68a0764f3116705808a124b9147ab6">crt_group_id_t</a> srv_grpid, <a class="el" href="structcrt__group.html">crt_group_t</a> **attached_grp)</td></tr>
<tr class="separator:ga69f78261760cc22432b6d79f591ef6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga488d62a433d3799355798075a9d2aa25"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga488d62a433d3799355798075a9d2aa25">crt_group_config_path_set</a> (const char *path)</td></tr>
<tr class="separator:ga488d62a433d3799355798075a9d2aa25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4524b67a753babb8236aa5628e46b273"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga4524b67a753babb8236aa5628e46b273">crt_group_config_save</a> (<a class="el" href="structcrt__group.html">crt_group_t</a> *grp, bool forall)</td></tr>
<tr class="separator:ga4524b67a753babb8236aa5628e46b273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fecd36a0cebf97f4a1dd8ad7fc17f70"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga1fecd36a0cebf97f4a1dd8ad7fc17f70">crt_group_config_remove</a> (<a class="el" href="structcrt__group.html">crt_group_t</a> *grp)</td></tr>
<tr class="separator:ga1fecd36a0cebf97f4a1dd8ad7fc17f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25fd9e4aeddc993b950f4f6d1b1cc5e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga25fd9e4aeddc993b950f4f6d1b1cc5e6">crt_group_detach</a> (<a class="el" href="structcrt__group.html">crt_group_t</a> *attached_grp)</td></tr>
<tr class="separator:ga25fd9e4aeddc993b950f4f6d1b1cc5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38f94d125e012d5ee8c7e7e1951977f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga38f94d125e012d5ee8c7e7e1951977f7">crt_group_rank_p2s</a> (<a class="el" href="structcrt__group.html">crt_group_t</a> *subgrp, d_rank_t rank_in, d_rank_t *rank_out)</td></tr>
<tr class="separator:ga38f94d125e012d5ee8c7e7e1951977f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ee5768a3251446b9032a2efa9e82956"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga1ee5768a3251446b9032a2efa9e82956">crt_group_rank_s2p</a> (<a class="el" href="structcrt__group.html">crt_group_t</a> *subgrp, d_rank_t rank_in, d_rank_t *rank_out)</td></tr>
<tr class="separator:ga1ee5768a3251446b9032a2efa9e82956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78eb548c0805c201b3ef45a3d0f57265"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga78eb548c0805c201b3ef45a3d0f57265">crt_corpc_req_create</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a> crt_ctx, <a class="el" href="structcrt__group.html">crt_group_t</a> *grp, d_rank_list_t *filter_ranks, <a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gae3dde8d6f8414e344befaafc0a3b7d3a">crt_opcode_t</a> opc, <a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga98854df58311faf6d4fcfb3c7554f66c">crt_bulk_t</a> co_bulk_hdl, void *priv, uint32_t flags, int tree_topo, <a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga22c4380156baf0663b9d7eee1ae65004">crt_rpc_t</a> **req)</td></tr>
<tr class="separator:ga78eb548c0805c201b3ef45a3d0f57265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba82673fa83307e86afef3fc3fea3961"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gaba82673fa83307e86afef3fc3fea3961">crt_corpc_register</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gae3dde8d6f8414e344befaafc0a3b7d3a">crt_opcode_t</a> opc, struct <a class="el" href="structcrt__req__format.html">crt_req_format</a> *drf, <a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga163a4cfb0f83c051338adb9a4c326eed">crt_rpc_cb_t</a> rpc_handler, struct <a class="el" href="structcrt__corpc__ops.html">crt_corpc_ops</a> *co_ops)</td></tr>
<tr class="separator:gaba82673fa83307e86afef3fc3fea3961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6195cef16a9b1d8fcd53c6a70f698bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gaa6195cef16a9b1d8fcd53c6a70f698bc">crt_group_rank</a> (<a class="el" href="structcrt__group.html">crt_group_t</a> *grp, d_rank_t *rank)</td></tr>
<tr class="separator:gaa6195cef16a9b1d8fcd53c6a70f698bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb3e7ce396595c4ccc7efd906fe0fc1f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gaeb3e7ce396595c4ccc7efd906fe0fc1f">crt_group_version</a> (<a class="el" href="structcrt__group.html">crt_group_t</a> *grp, uint32_t *version)</td></tr>
<tr class="separator:gaeb3e7ce396595c4ccc7efd906fe0fc1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga551bfde3b82cd593538596880b820e46"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga551bfde3b82cd593538596880b820e46">crt_group_version_set</a> (<a class="el" href="structcrt__group.html">crt_group_t</a> *grp, uint32_t version)</td></tr>
<tr class="separator:ga551bfde3b82cd593538596880b820e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3871193c4165b6dff00addb4836fc2a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga3871193c4165b6dff00addb4836fc2a6">crt_group_size</a> (<a class="el" href="structcrt__group.html">crt_group_t</a> *grp, uint32_t *size)</td></tr>
<tr class="separator:ga3871193c4165b6dff00addb4836fc2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga822752e99a7283692cd060fab6e1daee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga822752e99a7283692cd060fab6e1daee">crt_proc_get_op</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a> proc, <a class="el" href="group___c_a_r_t.html#gacfbc8243090b9821fcb4a138a205cb34">crt_proc_op_t</a> *proc_op)</td></tr>
<tr class="separator:ga822752e99a7283692cd060fab6e1daee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac68d7ff7120655c800ba09359640be50"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gac68d7ff7120655c800ba09359640be50">crt_proc_memcpy</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a> proc, void *data, size_t data_size)</td></tr>
<tr class="separator:gac68d7ff7120655c800ba09359640be50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ef07373df253f6c70ef1e1e45d322b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga4ef07373df253f6c70ef1e1e45d322b8">crt_proc_int8_t</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a> proc, int8_t *data)</td></tr>
<tr class="separator:ga4ef07373df253f6c70ef1e1e45d322b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91b123e3fa2287bd0a31ebf8cbc2a4f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga91b123e3fa2287bd0a31ebf8cbc2a4f0">crt_proc_uint8_t</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a> proc, uint8_t *data)</td></tr>
<tr class="separator:ga91b123e3fa2287bd0a31ebf8cbc2a4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ed12b03a85fba73bda6054fd6f53f20"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga2ed12b03a85fba73bda6054fd6f53f20">crt_proc_int16_t</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a> proc, int16_t *data)</td></tr>
<tr class="separator:ga2ed12b03a85fba73bda6054fd6f53f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b00ae9657ee806e0859e2a631987a94"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga7b00ae9657ee806e0859e2a631987a94">crt_proc_uint16_t</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a> proc, uint16_t *data)</td></tr>
<tr class="separator:ga7b00ae9657ee806e0859e2a631987a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa95f26166658b049482d10e6fee8ff28"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gaa95f26166658b049482d10e6fee8ff28">crt_proc_int32_t</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a> proc, int32_t *data)</td></tr>
<tr class="separator:gaa95f26166658b049482d10e6fee8ff28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26a21f8d43858142c598eee1387b12b7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga26a21f8d43858142c598eee1387b12b7">crt_proc_uint32_t</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a> proc, uint32_t *data)</td></tr>
<tr class="separator:ga26a21f8d43858142c598eee1387b12b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ff49fb8d9573d4f1d48c5262d5664e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga6ff49fb8d9573d4f1d48c5262d5664e7">crt_proc_int64_t</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a> proc, int64_t *data)</td></tr>
<tr class="separator:ga6ff49fb8d9573d4f1d48c5262d5664e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c220deeb56ef025dcbd69d6ca9d70d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga7c220deeb56ef025dcbd69d6ca9d70d4">crt_proc_uint64_t</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a> proc, uint64_t *data)</td></tr>
<tr class="separator:ga7c220deeb56ef025dcbd69d6ca9d70d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7e7c9babd4f43f0a1ae0b96f1702c7d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gaf7e7c9babd4f43f0a1ae0b96f1702c7d">crt_proc_bool</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a> proc, bool *data)</td></tr>
<tr class="separator:gaf7e7c9babd4f43f0a1ae0b96f1702c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga452dc384be3595f6d7bd286b86e61230"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga452dc384be3595f6d7bd286b86e61230">crt_proc_crt_bulk_t</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a> proc, <a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga98854df58311faf6d4fcfb3c7554f66c">crt_bulk_t</a> *bulk_hdl)</td></tr>
<tr class="separator:ga452dc384be3595f6d7bd286b86e61230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga778f5628eab28dfe9650d7a0ea189394"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga778f5628eab28dfe9650d7a0ea189394">crt_proc_d_string_t</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a> proc, d_string_t *data)</td></tr>
<tr class="separator:ga778f5628eab28dfe9650d7a0ea189394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae16aeb42e71f6607342c8a3d86a65367"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gae16aeb42e71f6607342c8a3d86a65367">crt_proc_d_const_string_t</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a> proc, d_const_string_t *data)</td></tr>
<tr class="separator:gae16aeb42e71f6607342c8a3d86a65367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4703edbf21168a660b18b993917878d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga4703edbf21168a660b18b993917878d8">crt_proc_uuid_t</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a> proc, uuid_t *data)</td></tr>
<tr class="separator:ga4703edbf21168a660b18b993917878d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ae2e6bf75b5f8b89b996d69ef98dc1d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga2ae2e6bf75b5f8b89b996d69ef98dc1d">crt_proc_d_rank_list_t</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a> proc, d_rank_list_t **data)</td></tr>
<tr class="separator:ga2ae2e6bf75b5f8b89b996d69ef98dc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8e5dddce30fb7643832ed05304e3d5a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gab8e5dddce30fb7643832ed05304e3d5a">crt_proc_d_iov_t</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a> proc, d_iov_t *data)</td></tr>
<tr class="separator:gab8e5dddce30fb7643832ed05304e3d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdc6b7a0637bd846543b97a89c3ef080"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gabdc6b7a0637bd846543b97a89c3ef080">crt_register_progress_cb</a> (crt_progress_cb cb, int ctx_idx, void *arg)</td></tr>
<tr class="separator:gabdc6b7a0637bd846543b97a89c3ef080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa63036cdba68a597084fe7a11da4aea7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gaa63036cdba68a597084fe7a11da4aea7">crt_unregister_progress_cb</a> (crt_progress_cb cb, int ctx_idx, void *arg)</td></tr>
<tr class="separator:gaa63036cdba68a597084fe7a11da4aea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab56d0dadd63ec9ee7c241aeb6d456ebd"><td class="memItemLeft" align="right" valign="top"><a id="gab56d0dadd63ec9ee7c241aeb6d456ebd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>crt_register_timeout_cb</b> (crt_timeout_cb cb, void *arg)</td></tr>
<tr class="separator:gab56d0dadd63ec9ee7c241aeb6d456ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf65c8659f71470294c9d702b78a86097"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gaf65c8659f71470294c9d702b78a86097">crt_register_event_cb</a> (crt_event_cb event_handler, void *arg)</td></tr>
<tr class="separator:gaf65c8659f71470294c9d702b78a86097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae333d240708c08ccd38ecf9df8449c35"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gae333d240708c08ccd38ecf9df8449c35">crt_unregister_event_cb</a> (crt_event_cb event_handler, void *arg)</td></tr>
<tr class="separator:gae333d240708c08ccd38ecf9df8449c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfdd482f95145207f5e591af771037a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gadfdd482f95145207f5e591af771037a2">crt_proto_register</a> (struct <a class="el" href="structcrt__proto__format.html">crt_proto_format</a> *cpf)</td></tr>
<tr class="separator:gadfdd482f95145207f5e591af771037a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe86d4600a2c1c1755c808b2834e7aa4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gafe86d4600a2c1c1755c808b2834e7aa4">crt_proto_query</a> (<a class="el" href="structcrt__endpoint__t.html">crt_endpoint_t</a> *tgt_ep, <a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gae3dde8d6f8414e344befaafc0a3b7d3a">crt_opcode_t</a> base_opc, uint32_t *ver, int count, <a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gac91077f0afeb8cf8f6dc6933d7e54a6b">crt_proto_query_cb_t</a> cb, void *arg)</td></tr>
<tr class="separator:gafe86d4600a2c1c1755c808b2834e7aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57f75b8ebd9c694b07c3aae13b9365ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga57f75b8ebd9c694b07c3aae13b9365ac">crt_rank_self_set</a> (d_rank_t rank)</td></tr>
<tr class="separator:ga57f75b8ebd9c694b07c3aae13b9365ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac61f182a8231c602267eafc5f1fc544f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gac61f182a8231c602267eafc5f1fc544f">crt_rank_uri_get</a> (<a class="el" href="structcrt__group.html">crt_group_t</a> *grp, d_rank_t rank, int tag, char **uri)</td></tr>
<tr class="separator:gac61f182a8231c602267eafc5f1fc544f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac627ee6b4355ab3e277453a60ee0174d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gac627ee6b4355ab3e277453a60ee0174d">crt_rank_state_get</a> (<a class="el" href="structcrt__group.html">crt_group_t</a> *grp, d_rank_t rank, struct <a class="el" href="structswim__member__state.html">swim_member_state</a> *state)</td></tr>
<tr class="separator:gac627ee6b4355ab3e277453a60ee0174d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f8f6d935bf918c31003c82cc02bd55b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga4f8f6d935bf918c31003c82cc02bd55b">crt_group_rank_remove</a> (<a class="el" href="structcrt__group.html">crt_group_t</a> *group, d_rank_t rank)</td></tr>
<tr class="separator:ga4f8f6d935bf918c31003c82cc02bd55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6b2b86a7bc35f74afebcbe1dac4ca87"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gad6b2b86a7bc35f74afebcbe1dac4ca87">crt_self_uri_get</a> (int tag, char **uri)</td></tr>
<tr class="separator:gad6b2b86a7bc35f74afebcbe1dac4ca87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcba15a416034cca857d610726be3d7b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gafcba15a416034cca857d610726be3d7b">crt_group_info_get</a> (<a class="el" href="structcrt__group.html">crt_group_t</a> *group, d_iov_t *grp_info)</td></tr>
<tr class="separator:gafcba15a416034cca857d610726be3d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad03bd00dfb94ae9df11d9b6d70297821"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gad03bd00dfb94ae9df11d9b6d70297821">crt_group_info_set</a> (d_iov_t *grp_info)</td></tr>
<tr class="separator:gad03bd00dfb94ae9df11d9b6d70297821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga404d78b73d711f7de5d997676fea00b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga404d78b73d711f7de5d997676fea00b5">crt_group_ranks_get</a> (<a class="el" href="structcrt__group.html">crt_group_t</a> *group, d_rank_list_t **list)</td></tr>
<tr class="separator:ga404d78b73d711f7de5d997676fea00b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga276c01c89aa5db8c3cdd1fd12fa6cde0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga276c01c89aa5db8c3cdd1fd12fa6cde0">crt_group_view_create</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gade68a0764f3116705808a124b9147ab6">crt_group_id_t</a> grpid, <a class="el" href="structcrt__group.html">crt_group_t</a> **ret_grp)</td></tr>
<tr class="separator:ga276c01c89aa5db8c3cdd1fd12fa6cde0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d2535be2fa010039ae73222af0c603b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga9d2535be2fa010039ae73222af0c603b">crt_group_view_destroy</a> (<a class="el" href="structcrt__group.html">crt_group_t</a> *grp)</td></tr>
<tr class="separator:ga9d2535be2fa010039ae73222af0c603b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18ffa8213adb6c0df49fb917b32087a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga18ffa8213adb6c0df49fb917b32087a7">crt_group_psr_set</a> (<a class="el" href="structcrt__group.html">crt_group_t</a> *grp, d_rank_t rank)</td></tr>
<tr class="separator:ga18ffa8213adb6c0df49fb917b32087a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f31926b084149cfbe4ba581075a23e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga9f31926b084149cfbe4ba581075a23e3">crt_group_psrs_set</a> (<a class="el" href="structcrt__group.html">crt_group_t</a> *grp, d_rank_list_t *rank_list)</td></tr>
<tr class="separator:ga9f31926b084149cfbe4ba581075a23e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5849954786bca2e5668a51f10641851a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga5849954786bca2e5668a51f10641851a">crt_group_primary_rank_add</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a> ctx, <a class="el" href="structcrt__group.html">crt_group_t</a> *grp, d_rank_t primary_rank, char *uri)</td></tr>
<tr class="separator:ga5849954786bca2e5668a51f10641851a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6763a139366b59f7181c797fc40cd9d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga6763a139366b59f7181c797fc40cd9d6">crt_group_secondary_rank_add</a> (<a class="el" href="structcrt__group.html">crt_group_t</a> *grp, d_rank_t secondary_rank, d_rank_t primary_rank)</td></tr>
<tr class="separator:ga6763a139366b59f7181c797fc40cd9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd785115d57a80cb730db77abb373b16"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gafd785115d57a80cb730db77abb373b16">crt_group_secondary_create</a> (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gade68a0764f3116705808a124b9147ab6">crt_group_id_t</a> grp_name, <a class="el" href="structcrt__group.html">crt_group_t</a> *primary_grp, d_rank_list_t *ranks, <a class="el" href="structcrt__group.html">crt_group_t</a> **ret_grp)</td></tr>
<tr class="separator:gafd785115d57a80cb730db77abb373b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadae1ac0327dd9ad5049299bc4f565fb0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gadae1ac0327dd9ad5049299bc4f565fb0">crt_group_auto_rank_remove</a> (<a class="el" href="structcrt__group.html">crt_group_t</a> *grp, bool enable)</td></tr>
<tr class="separator:gadae1ac0327dd9ad5049299bc4f565fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f780239bb28215e64aa3edb7e36021a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga1f780239bb28215e64aa3edb7e36021a">crt_group_secondary_destroy</a> (<a class="el" href="structcrt__group.html">crt_group_t</a> *grp)</td></tr>
<tr class="separator:ga1f780239bb28215e64aa3edb7e36021a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa18493edb4133011d65bbae0176da16b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#gaa18493edb4133011d65bbae0176da16b">crt_group_primary_modify</a> (<a class="el" href="structcrt__group.html">crt_group_t</a> *grp, <a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a> *ctxs, int num_ctxs, d_rank_list_t *ranks, char **uris, <a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga45d6c2aa7ad84115a6398b74d29150e5">crt_group_mod_op_t</a> op, uint32_t version)</td></tr>
<tr class="separator:gaa18493edb4133011d65bbae0176da16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a8c919b8f0d85264425e45311205b70"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga5a8c919b8f0d85264425e45311205b70">crt_group_secondary_modify</a> (<a class="el" href="structcrt__group.html">crt_group_t</a> *grp, d_rank_list_t *sec_ranks, d_rank_list_t *prim_ranks, <a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga45d6c2aa7ad84115a6398b74d29150e5">crt_group_mod_op_t</a> op, uint32_t version)</td></tr>
<tr class="separator:ga5a8c919b8f0d85264425e45311205b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bab597f86d13a32ae1ed335f3eda7bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga3bab597f86d13a32ae1ed335f3eda7bd">crt_swim_init</a> (int crt_ctx_idx)</td></tr>
<tr class="separator:ga3bab597f86d13a32ae1ed335f3eda7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c54f3ae1017bc377f5824766c531a01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_r_t.html#ga6c54f3ae1017bc377f5824766c531a01">crt_swim_fini</a> (void)</td></tr>
<tr class="separator:ga6c54f3ae1017bc377f5824766c531a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga7aa8c8adbbe2ac33f3a1eebd040388c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7aa8c8adbbe2ac33f3a1eebd040388c2">&#9670;&nbsp;</a></span>crt_bulk_decref</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define crt_bulk_decref</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bulk_hdl</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group___c_a_r_t.html#gac6dabec2240d728d62bacec3d2a89df7">crt_bulk_free</a>(bulk_hdl)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decrease reference of the bulk handle. </p>

<p class="definition">Definition at line <a class="el" href="api_8h_source.html#l00991">991</a> of file <a class="el" href="api_8h_source.html">api.h</a>.</p>

</div>
</div>
<a id="ga8199b325289cd50bf713a97b51446255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8199b325289cd50bf713a97b51446255">&#9670;&nbsp;</a></span>CRT_GEN_PROC_FUNC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRT_GEN_PROC_FUNC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">seq&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">static</span> <span class="keywordtype">int</span> crt_proc_struct_##type_name(<a class="code" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a> proc,     \</div>
<div class="line">                           <span class="keyword">struct</span> type_name *ptr) { \</div>
<div class="line">        int rc = 0;                     \</div>
<div class="line">        if (proc == NULL || ptr == NULL)            \</div>
<div class="line">            D_GOTO(out, rc = -DER_INVAL);           \</div>
<div class="line">        BOOST_PP_SEQ_FOR_EACH(CRT_GEN_PROC_FIELD, ptr, seq) \</div>
<div class="line">    out:                                \</div>
<div class="line">        return rc;                      \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="api_8h_source.html#l00770">770</a> of file <a class="el" href="api_8h_source.html">api.h</a>.</p>

</div>
</div>
<a id="gaf2c6a8f789ef6e904a1dc1a89368c52a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2c6a8f789ef6e904a1dc1a89368c52a">&#9670;&nbsp;</a></span>CRT_GEN_STRUCT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRT_GEN_STRUCT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">struct_type_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">seq&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">struct </span>struct_type_name {                   \</div>
<div class="line">        BOOST_PP_SEQ_FOR_EACH(CRT_GEN_STRUCT_FIELD, , seq)  \</div>
<div class="line">    };</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="api_8h_source.html#l00707">707</a> of file <a class="el" href="api_8h_source.html">api.h</a>.</p>

</div>
</div>
<a id="ga7f57d141918ce10f867c1932687166e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f57d141918ce10f867c1932687166e9">&#9670;&nbsp;</a></span>CRT_GEN_STRUCT_FIELD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRT_GEN_STRUCT_FIELD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">r, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">seq&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    BOOST_PP_IF(BOOST_PP_EQUAL(CRT_ARRAY, CRT_GEN_GET_KIND(seq)),   \</div>
<div class="line">        <span class="keyword">struct</span> {                        \</div>
<div class="line">            uint64_t         ca_count;      \</div>
<div class="line">            CRT_GEN_GET_TYPE(seq)   *ca_arrays;     \</div>
<div class="line">        },                          \</div>
<div class="line">        CRT_GEN_GET_TYPE(seq))                  \</div>
<div class="line">    BOOST_PP_IF(BOOST_PP_EQUAL(CRT_PTR, CRT_GEN_GET_KIND(seq)), \</div>
<div class="line">        *CRT_GEN_GET_NAME(seq), CRT_GEN_GET_NAME(seq));</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="api_8h_source.html#l00697">697</a> of file <a class="el" href="api_8h_source.html">api.h</a>.</p>

</div>
</div>
<a id="ga861a3ced53f5701d716737b48f986afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga861a3ced53f5701d716737b48f986afb">&#9670;&nbsp;</a></span>crt_proc_struct</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define crt_proc_struct</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    BOOST_PP_RPAREN() BOOST_PP_CAT BOOST_PP_LPAREN() \</div>
<div class="line">    crt_proc_struct_,</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="api_8h_source.html#l00713">713</a> of file <a class="el" href="api_8h_source.html">api.h</a>.</p>

</div>
</div>
<a id="gaf3875cc9d015cd8f5e18e63e06bea925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3875cc9d015cd8f5e18e63e06bea925">&#9670;&nbsp;</a></span>CRT_RPC_DECLARE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRT_RPC_DECLARE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rpc_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fields_in, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fields_out&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    BOOST_PP_IF(BOOST_PP_SEQ_SIZE(fields_in),           \</div>
<div class="line">        CRT_GEN_STRUCT(rpc_name##_in, fields_in), )     \</div>
<div class="line">    BOOST_PP_IF(BOOST_PP_SEQ_SIZE(fields_out),          \</div>
<div class="line">        CRT_GEN_STRUCT(rpc_name##_out, fields_out), )       \</div>
<div class="line">    extern <span class="keyword">struct </span><a class="code" href="structcrt__req__format.html">crt_req_format</a> CQF_##rpc_name;</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="api_8h_source.html#l00781">781</a> of file <a class="el" href="api_8h_source.html">api.h</a>.</p>

</div>
</div>
<a id="ga62c11e872f6451559fe92b2e6482e274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62c11e872f6451559fe92b2e6482e274">&#9670;&nbsp;</a></span>CRT_RPC_DEFINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRT_RPC_DEFINE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rpc_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fields_in, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fields_out&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    BOOST_PP_IF(BOOST_PP_SEQ_SIZE(fields_in),           \</div>
<div class="line">        CRT_GEN_PROC_FUNC(rpc_name##_in, fields_in), )      \</div>
<div class="line">    BOOST_PP_IF(BOOST_PP_SEQ_SIZE(fields_out),          \</div>
<div class="line">        CRT_GEN_PROC_FUNC(rpc_name##_out, fields_out), )    \</div>
<div class="line">    _Pragma(<span class="stringliteral">&quot;GCC diagnostic push&quot;</span>)                  \</div>
<div class="line">    CRT_DISABLE_SIZEOF_POINTER_DIV                  \</div>
<div class="line">    struct <a class="code" href="structcrt__req__format.html">crt_req_format</a> CQF_##rpc_name = {            \</div>
<div class="line">        .crf_proc_in  = (<a class="code" href="group___c_a_r_t___t_y_p_e_s.html#ga1266fedf6067dbd6400b70730468145a">crt_proc_cb_t</a>)             \</div>
<div class="line">        BOOST_PP_IF(BOOST_PP_SEQ_SIZE(fields_in),       \</div>
<div class="line">            crt_proc_struct_##rpc_name##_in, NULL),     \</div>
<div class="line">        .crf_proc_out = (<a class="code" href="group___c_a_r_t___t_y_p_e_s.html#ga1266fedf6067dbd6400b70730468145a">crt_proc_cb_t</a>)             \</div>
<div class="line">        BOOST_PP_IF(BOOST_PP_SEQ_SIZE(fields_out),      \</div>
<div class="line">            crt_proc_struct_##rpc_name##_out, NULL),    \</div>
<div class="line">        .crf_size_in  =                     \</div>
<div class="line">        BOOST_PP_IF(BOOST_PP_SEQ_SIZE(fields_in),       \</div>
<div class="line">            <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rpc_name##_in), 0),       \</div>
<div class="line">        .crf_size_out =                     \</div>
<div class="line">        BOOST_PP_IF(BOOST_PP_SEQ_SIZE(fields_out),      \</div>
<div class="line">            <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rpc_name##_out), 0)       \</div>
<div class="line">    };                              \</div>
<div class="line">    _Pragma(<span class="stringliteral">&quot;GCC diagnostic pop&quot;</span>)</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="api_8h_source.html#l00796">796</a> of file <a class="el" href="api_8h_source.html">api.h</a>.</p>

</div>
</div>
<a id="ga660a415dda17860766a23f515fa69964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga660a415dda17860766a23f515fa69964">&#9670;&nbsp;</a></span>CRT_VAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CRT_VAR&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CART provides a set of macros for RPC registration. Using the macro interface to register RPCs is much simpler and reduces the opportunities for mistakes.</p>
<p>public macros: </p><pre class="fragment">preparation:
    - CRT_RPC_DECLARE()
    - CRT_RPC_DEFINE()

registration:
    - CRT_RPC_REGISTER()
    - CRT_RPC_SRV_REGISTER()
</pre><p>To register an RPC using macros: CRT_RPC_DECLARE(my_rpc_name, input_fields, output_fields) CRT_RPC_DEFINE(my_rpc_name, input_fields, output_fields) CRT_RPC_REGISTER(opcode, flags, my_rpc_name);</p>
<p>The input/output structs can be accessed using the following pointers: struct my_rpc_name_in *rpc_in; struct my_rpc_name_out *rpc_out; Prepare struct types and format description for the input/output of an RPC. Supported types in the fields_in/fields_out list can be found in <a class="el" href="types_8h.html">include/cart/types.h</a></p>
<p>Example usage:</p>
<p>#define CRT_ISEQ_MY_RPC ((int32_t) (mr_arg_1) CRT_VAR) ((uint32_t) (mr_arg_2) CRT_VAR) ((d_rank_t) (mr_rank) CRT_VAR) ((d_rank_list_t) (mr_rank_list) CRT_PTR) ((uuid_t) (mr_array) CRT_ARRAY) ((d_string_t) (mr_name) CRT_VAR)</p>
<p>#define CRT_OSEQ_MY_RPC ((int32_t) (mr_ret) CRT_VAR)</p>
<p>CRT_RPC_DECLARE(my_rpc, CRT_ISEQ_MY_RPC, CRT_OSEQ_MY_RPC) CRT_RPC_REGISTER(opcode, flags, my_rpc);</p>
<p>these two macros above expands into:</p>
<p>struct my_rpc_in { int32_t mr_arg_1; uint32_t mr_arg_2; d_rank_t mr_rank; d_rank_list_t *mr_rank_list; struct crt_array mr_array; d_string_t mr_name; };</p>
<p>struct my_rpc_out { int32_t mr_ret; };</p>
<p>crt_register(opcode, flags, &amp;CQF_my_rpc);</p>
<p>the macros CRT_RPC_DEFINE(my_rpc, CRT_ISEQ_MY_RPC, CRT_OSEQ_MY_RPC) expands into internal RPC definition which will be used in RPC registration. The content of this macro expansion will be changed in the future.</p>
<p>To use array types it's possible to define types as above, and then use the same macros to declare types and proc structs for types, and then reference the type directly in the RPC definition.</p>
<p>CRT_GEN_STRUCT(struct, CRT_SEQ_MY_TYPE) </p><h1>CRT_GEN_PROC_FUNC(struct, CRT_SEQ_MY_TYPE)</h1>

<p class="definition">Definition at line <a class="el" href="api_8h_source.html#l00688">688</a> of file <a class="el" href="api_8h_source.html">api.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gab814fd7c6d7030a7ff733c3180f3c426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab814fd7c6d7030a7ff733c3180f3c426">&#9670;&nbsp;</a></span>crt_rpc_task_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* crt_rpc_task_t) (<a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a> *ctx, void *rpc_hdlr_arg, void(*rpc_hdlr)(void *), void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The RPC callback for the context, which will be called when the context receives any RPC. In this callback, the handler can do sth specially for the RPC on this context, for example create another ULT to handle it, see DAOS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>The cart context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rpc_hdlr_arg</td><td>The argument of rpc_hdlr. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rpc_hdlr</td><td>Real RPC handler. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Extra argument for the callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, negative value if failed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="api_8h_source.html#l00860">860</a> of file <a class="el" href="api_8h_source.html">api.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga77aaf444cca8082606259c3cb873f142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77aaf444cca8082606259c3cb873f142">&#9670;&nbsp;</a></span>crt_event_source</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_a_r_t.html#ga77aaf444cca8082606259c3cb873f142">crt_event_source</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga77aaf444cca8082606259c3cb873f142a1d3a451747b0335f4b51113d994196b6"></a>CRT_EVS_UNKNOWN&#160;</td><td class="fielddoc"><p>Event triggered by SWIM &gt; </p>
</td></tr>
<tr><td class="fieldname"><a id="gga77aaf444cca8082606259c3cb873f142a665dd87be3339053386d96020e7b3cc9"></a>CRT_EVS_SWIM&#160;</td><td class="fielddoc"><p>Event triggered by Group changes &gt; </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="api_8h_source.html#l01652">1652</a> of file <a class="el" href="api_8h_source.html">api.h</a>.</p>

</div>
</div>
<a id="gacfbc8243090b9821fcb4a138a205cb34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfbc8243090b9821fcb4a138a205cb34">&#9670;&nbsp;</a></span>crt_proc_op_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_a_r_t.html#gacfbc8243090b9821fcb4a138a205cb34">crt_proc_op_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggacfbc8243090b9821fcb4a138a205cb34a356d2703575b63de86a40aa29cc4fbde"></a>CRT_PROC_ENCODE&#160;</td><td class="fielddoc"><p>causes the type to be encoded into the stream </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacfbc8243090b9821fcb4a138a205cb34a1d32757630fc4bb27314f7ed495fc172"></a>CRT_PROC_DECODE&#160;</td><td class="fielddoc"><p>causes the type to be extracted from the stream </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacfbc8243090b9821fcb4a138a205cb34a476f3ed609dd4936e15f34765bdb69ff"></a>CRT_PROC_FREE&#160;</td><td class="fielddoc"><p>can be used to release the space allocated by CRT_DECODE request </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="api_8h_source.html#l01421">1421</a> of file <a class="el" href="api_8h_source.html">api.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga62bfa2cc197157396a2d9a27bd85503a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62bfa2cc197157396a2d9a27bd85503a">&#9670;&nbsp;</a></span>crt_bulk_access()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_bulk_access </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga98854df58311faf6d4fcfb3c7554f66c">crt_bulk_t</a>&#160;</td>
          <td class="paramname"><em>bulk_hdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_sg_list_t *&#160;</td>
          <td class="paramname"><em>sgl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access local bulk handle to retrieve the sgl (segment list) associated with it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bulk_hdl</td><td>bulk handle </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sgl</td><td>pointer to buffer segment list Caller should provide a valid sgl pointer, if sgl-&gt;sg_nr is too small, -DER_TRUNC will be returned and the needed number of iovs be set at sgl-&gt;sg_nr_out. On success, sgl-&gt;sg_nr_out will be set as the actual number of iovs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="ga71778dc6e151ae5cb915e251a94053f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71778dc6e151ae5cb915e251a94053f0">&#9670;&nbsp;</a></span>crt_bulk_addref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_bulk_addref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga98854df58311faf6d4fcfb3c7554f66c">crt_bulk_t</a>&#160;</td>
          <td class="paramname"><em>bulk_hdl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add reference of the bulk handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bulk_hdl</td><td>bulk handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="gac66777b15f7a835cf8806ff91199b0fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac66777b15f7a835cf8806ff91199b0fa">&#9670;&nbsp;</a></span>crt_bulk_bind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_bulk_bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga98854df58311faf6d4fcfb3c7554f66c">crt_bulk_t</a>&#160;</td>
          <td class="paramname"><em>bulk_hdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a>&#160;</td>
          <td class="paramname"><em>crt_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bind bulk handle to local context, to associate the origin address of the local context to the bulk handle.</p>
<p>It can be used to forward/share the bulk handle from one server to another server, in that case the origin address of the bulk handle can be serialized/ de-serialized on-the-fly. The example usage: client sends a RPC request with a bulk handle embedded to server A, server A forward the client-side bulk handle to another server B. For that usage, client should call this API to bind the bulk handle with its local context before sending the RPC to server A. So when server B gets the de-serialized bulk handle forwarded by server A, the server B can know the client-side origin address to do the bulk transferring.</p>
<p>Users should note that binding a bulk handle adds an extra overhead on serialization, therefore it is recommended to use it with care. When binding a bulk handle on origin, <a class="el" href="group___c_a_r_t.html#ga219734f8633dcbe40254e7586f9ff810">crt_bulk_bind_transfer()</a> should be used since origin address information is embedded in the handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bulk_hdl</td><td>created bulk handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">crt_ctx</td><td>CRT transport context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="ga219734f8633dcbe40254e7586f9ff810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga219734f8633dcbe40254e7586f9ff810">&#9670;&nbsp;</a></span>crt_bulk_bind_transfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_bulk_bind_transfer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcrt__bulk__desc.html">crt_bulk_desc</a> *&#160;</td>
          <td class="paramname"><em>bulk_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf25e76b2c5b895478f2b640af5ef9405">crt_bulk_cb_t</a>&#160;</td>
          <td class="paramname"><em>complete_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">crt_bulk_opid_t *&#160;</td>
          <td class="paramname"><em>opid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start a bulk transferring by using the remote bulk handle bound address rather than the RPC's origin address. It can be used for the case that the origin address of bulk handle is different with RPC request, for example DAOS' bulk handle forwarding for server-side I/O dispatching.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bulk_desc</td><td>pointer to bulk transferring descriptor it is user's responsibility to allocate and free it. Can free it after the calling returns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">complete_cb</td><td>completion callback </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>arguments for the <em>complete_cb</em> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">opid</td><td>returned bulk opid which can be used to abort the bulk. It is optional, can pass in NULL if don't need it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="gaba8a38409ed5a85ae321b6824dafa2a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba8a38409ed5a85ae321b6824dafa2a4">&#9670;&nbsp;</a></span>crt_bulk_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_bulk_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a>&#160;</td>
          <td class="paramname"><em>crt_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_sg_list_t *&#160;</td>
          <td class="paramname"><em>sgl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga0baa03079c26075653589c9138e74e0e">crt_bulk_perm_t</a>&#160;</td>
          <td class="paramname"><em>bulk_perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga98854df58311faf6d4fcfb3c7554f66c">crt_bulk_t</a> *&#160;</td>
          <td class="paramname"><em>bulk_hdl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a bulk handle</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">crt_ctx</td><td>CRT transport context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sgl</td><td>pointer to buffer segment list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bulk_perm</td><td>bulk permission, See <a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga0baa03079c26075653589c9138e74e0e">crt_bulk_perm_t</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bulk_hdl</td><td>created bulk handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="gac6dabec2240d728d62bacec3d2a89df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6dabec2240d728d62bacec3d2a89df7">&#9670;&nbsp;</a></span>crt_bulk_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_bulk_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga98854df58311faf6d4fcfb3c7554f66c">crt_bulk_t</a>&#160;</td>
          <td class="paramname"><em>bulk_hdl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free a bulk handle</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bulk_hdl</td><td>bulk handle to be freed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="ga8ad87ffb793d7e1ada6a9c2a2a9faaa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ad87ffb793d7e1ada6a9c2a2a9faaa2">&#9670;&nbsp;</a></span>crt_bulk_get_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_bulk_get_len </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga98854df58311faf6d4fcfb3c7554f66c">crt_bulk_t</a>&#160;</td>
          <td class="paramname"><em>bulk_hdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>bulk_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get length (number of bytes) of data abstracted by bulk handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bulk_hdl</td><td>bulk handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bulk_len</td><td>length of the data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="gaad009bd02a5e2bc06d63e35fb87dfadc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad009bd02a5e2bc06d63e35fb87dfadc">&#9670;&nbsp;</a></span>crt_bulk_get_sgnum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_bulk_get_sgnum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga98854df58311faf6d4fcfb3c7554f66c">crt_bulk_t</a>&#160;</td>
          <td class="paramname"><em>bulk_hdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>bulk_sgnum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of segments of data abstracted by bulk handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bulk_hdl</td><td>bulk handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bulk_sgnum</td><td>number of segments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="gaae90d605eafc12f8c90e7aa430b87679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae90d605eafc12f8c90e7aa430b87679">&#9670;&nbsp;</a></span>crt_bulk_transfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_bulk_transfer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcrt__bulk__desc.html">crt_bulk_desc</a> *&#160;</td>
          <td class="paramname"><em>bulk_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf25e76b2c5b895478f2b640af5ef9405">crt_bulk_cb_t</a>&#160;</td>
          <td class="paramname"><em>complete_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">crt_bulk_opid_t *&#160;</td>
          <td class="paramname"><em>opid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start a bulk transferring (inside an RPC handler).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bulk_desc</td><td>pointer to bulk transferring descriptor it is user's responsibility to allocate and free it. Can free it after the calling returns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">complete_cb</td><td>completion callback </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>arguments for the <em>complete_cb</em> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">opid</td><td>returned bulk opid which can be used to abort the bulk. It is optional, can pass in NULL if don't need it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="ga07eb1757b968c01796e32a5b9350cb8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07eb1757b968c01796e32a5b9350cb8f">&#9670;&nbsp;</a></span>crt_context_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_context_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a> *&#160;</td>
          <td class="paramname"><em>crt_ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create CRT transport context. Must be destroyed by <a class="el" href="group___c_a_r_t.html#ga0bbef2e88904b5ff96ac5e026727ebc3">crt_context_destroy()</a> before calling <a class="el" href="group___c_a_r_t.html#gac4586b6542b4c809a737a63e18b6f314">crt_finalize()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">crt_ctx</td><td>created CRT transport context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="ga0bbef2e88904b5ff96ac5e026727ebc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bbef2e88904b5ff96ac5e026727ebc3">&#9670;&nbsp;</a></span>crt_context_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_context_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a>&#160;</td>
          <td class="paramname"><em>crt_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>force</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy CRT transport context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">crt_ctx</td><td>CRT transport context to be destroyed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">force</td><td>1) force == 0 return as -EBUSY if there is any in-flight RPC request, so caller can wait its completion or timeout. 2) force != 0 will cancel all in-flight RPC requests.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Currently there is no in-flight list/queue in mercury. </dd></dl>

</div>
</div>
<a id="ga1bbbd9ba3a54384b8c41470652d3f222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bbbd9ba3a54384b8c41470652d3f222">&#9670;&nbsp;</a></span>crt_context_ep_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crt_context_ep_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a>&#160;</td>
          <td class="paramname"><em>crt_ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>check if the endpoint associated with <em>crt_ctx</em> is empty i.e. has no pending RPCs</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">crt_ctx</td><td>CRT transport context to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>crt_ctx</em> is empty, false if <em>crt_ctx</em> is not empty </dd></dl>

</div>
</div>
<a id="ga8cd1507f48cd4c6e7a74def265859a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cd1507f48cd4c6e7a74def265859a5c">&#9670;&nbsp;</a></span>crt_context_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_context_flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a>&#160;</td>
          <td class="paramname"><em>crt_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flush pending RPCs associated with the specified context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">crt_ctx</td><td>CRT transport context to flush </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>max time duration (in seconds) to try to flush. 0 means infinite timeout. After <em>timeout</em> amount of time, this function will return even if there are still RPCs pending.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS if there are no more pending RPCs, -DER_TIMEDOUT if time out is reached before all RPCs are processed, other negative value on error </dd></dl>

</div>
</div>
<a id="gaead25d94b1228f3a3c33b0a60a7b482f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaead25d94b1228f3a3c33b0a60a7b482f">&#9670;&nbsp;</a></span>crt_context_idx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_context_idx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a>&#160;</td>
          <td class="paramname"><em>crt_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ctx_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query the index of the transport context, the index value ranges in [0, ctx_num - 1].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">crt_ctx</td><td>CRT transport context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_idx</td><td>pointer to the returned index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="ga4fed553ebd62a4ff404b339cf3e2a5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fed553ebd62a4ff404b339cf3e2a5e4">&#9670;&nbsp;</a></span>crt_context_num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_context_num </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ctx_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query the total number of the transport contexts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ctx_num</td><td>pointer to the returned number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="ga383347752c15c431a5eabedafc2d2910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga383347752c15c431a5eabedafc2d2910">&#9670;&nbsp;</a></span>crt_context_register_rpc_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_context_register_rpc_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a>&#160;</td>
          <td class="paramname"><em>crt_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t.html#gab814fd7c6d7030a7ff733c3180f3c426">crt_rpc_task_t</a>&#160;</td>
          <td class="paramname"><em>rpc_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t.html#gab814fd7c6d7030a7ff733c3180f3c426">crt_rpc_task_t</a>&#160;</td>
          <td class="paramname"><em>iv_resp_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register RPC process callback for all RPCs this context received. This callback enables the thread to modify how the rpc callbacks are handled for this context. For example DAOS creates another argobot ULT to handle it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">crt_ctx</td><td>The context to be registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rpc_cb</td><td>The RPC process callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iv_reps_cb</td><td>The IV response callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>The argument for RPC process callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error. </dd></dl>

</div>
</div>
<a id="ga0c292fc8a9b62dca06eab39f6f598423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c292fc8a9b62dca06eab39f6f598423">&#9670;&nbsp;</a></span>crt_context_set_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_context_set_timeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a>&#160;</td>
          <td class="paramname"><em>crt_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout_sec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the timeout value for all RPC requests created on the specified context. Setting the timeout after <a class="el" href="group___c_a_r_t.html#ga620993c739a94ff703d78ce92a630c56">crt_req_create()</a> call will not affect already created rpcs.</p>
<p>This is an optional function.</p>
<p>The precedence order of timeouts:</p><ul>
<li><a class="el" href="group___c_a_r_t.html#ga5613cf2c576e417c441f66416c0a816d">crt_req_set_timeout()</a></li>
<li><a class="el" href="group___c_a_r_t.html#ga0c292fc8a9b62dca06eab39f6f598423">crt_context_set_timeout()</a></li>
<li>CRT_TIMEOUT environment variable</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">crt_ctx</td><td>CaRT context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_sec</td><td>timeout value in seconds value of zero will be treated as invalid parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="gaba82673fa83307e86afef3fc3fea3961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba82673fa83307e86afef3fc3fea3961">&#9670;&nbsp;</a></span>crt_corpc_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_corpc_register </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gae3dde8d6f8414e344befaafc0a3b7d3a">crt_opcode_t</a>&#160;</td>
          <td class="paramname"><em>opc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcrt__req__format.html">crt_req_format</a> *&#160;</td>
          <td class="paramname"><em>drf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga163a4cfb0f83c051338adb9a4c326eed">crt_rpc_cb_t</a>&#160;</td>
          <td class="paramname"><em>rpc_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcrt__corpc__ops.html">crt_corpc_ops</a> *&#160;</td>
          <td class="paramname"><em>co_ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dynamically register a collective RPC. Can only be called on the server side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">opc</td><td>unique opcode for the RPC </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">drf</td><td>pointer to the request format, which describe the request format and provide callback to pack/unpack each items in the request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rpc_handler</td><td>pointer to RPC handler which will be triggered when RPC request opcode associated with rpc_name is received. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">co_ops</td><td>pointer to corpc ops table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>1) User can use crt_rpc_srv_reg to register collective RPC if no reply aggregation needed. 2) Can pass in a NULL drf or rpc_handler if it was registered already, this routine only overwrite if they are non-NULL. 3) A NULL co_ops is allowed for the case that user does not need the corpc op table (the aggregating callback).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="ga78eb548c0805c201b3ef45a3d0f57265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78eb548c0805c201b3ef45a3d0f57265">&#9670;&nbsp;</a></span>crt_corpc_req_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_corpc_req_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a>&#160;</td>
          <td class="paramname"><em>crt_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcrt__group.html">crt_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_rank_list_t *&#160;</td>
          <td class="paramname"><em>filter_ranks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gae3dde8d6f8414e344befaafc0a3b7d3a">crt_opcode_t</a>&#160;</td>
          <td class="paramname"><em>opc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga98854df58311faf6d4fcfb3c7554f66c">crt_bulk_t</a>&#160;</td>
          <td class="paramname"><em>co_bulk_hdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>priv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tree_topo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga22c4380156baf0663b9d7eee1ae65004">crt_rpc_t</a> **&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create collective RPC request. Can reuse the crt_req_send to broadcast it. Can only be called on the server side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">crt_ctx</td><td>CRT context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grp</td><td>CRT group for the collective RPC </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_ranks</td><td>optional filter ranks. By default, the RPC will be delivered to all members in the group except those in <em>filter_ranks</em>. If <em>flags</em> includes CRT_RPC_FLAG_FILTER_INVERT, the RPC will be delivered to <em>filter_ranks</em> only. The ranks are numbered in primary group. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opc</td><td>unique opcode for the RPC </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">co_bulk_hdl</td><td>collective bulk handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priv</td><td>A private pointer associated with the request will be passed to <a class="el" href="structcrt__corpc__ops.html#af99db443bd1d126cfe017fbb58880708">crt_corpc_ops::co_aggregate</a> as 2nd parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>collective RPC flags: CRT_RPC_FLAG_FILTER_INVERT to send only to <em>filter_ranks</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree_topo</td><td>tree topology for the collective propagation, can be calculated by crt_tree_topo(). See <em>crt_tree_type</em>, <em>crt_tree_topo()</em>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">req</td><td>[out] created collective RPC request</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="gab49687fc6b749807872c6c14f6dbf7ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab49687fc6b749807872c6c14f6dbf7ab">&#9670;&nbsp;</a></span>crt_ep_abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_ep_abort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrt__endpoint__t.html">crt_endpoint_t</a> *&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DEPRECATED:</p>
<p>Abort all in-flight RPC requests targeting to an endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>endpoint address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="gac4586b6542b4c809a737a63e18b6f314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4586b6542b4c809a737a63e18b6f314">&#9670;&nbsp;</a></span>crt_finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_finalize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finalize CRT transport layer. Must be called on both the server side and client side before exit. This function is reference counted.</p>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="ga69f78261760cc22432b6d79f591ef6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69f78261760cc22432b6d79f591ef6f6">&#9670;&nbsp;</a></span>crt_group_attach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_group_attach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gade68a0764f3116705808a124b9147ab6">crt_group_id_t</a>&#160;</td>
          <td class="paramname"><em>srv_grpid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcrt__group.html">crt_group_t</a> **&#160;</td>
          <td class="paramname"><em>attached_grp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attach to a primary service group.</p>
<p>By calling this function to attach to service primary group, and set <a class="el" href="structcrt__endpoint__t.html#aa5ce92d465b2def135da62d9a29058c0">crt_endpoint_t::ep_grp</a> as the returned attached_grp to send RPC to it.</p>
<p>For client, the first attached service primary group become its default service primary group. For server, its default service primary group is the primary group created in crt_init(). User can pass <a class="el" href="structcrt__endpoint__t.html#aa5ce92d465b2def135da62d9a29058c0">crt_endpoint_t::ep_grp</a> pointer as NULL to send RPC to the default service primary group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srv_grpid</td><td>Primary service group ID to attach to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">attached_grp</td><td>Returned attached group handle pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Make sure cart context 0 exists when calling this function. cart context 0 is created by the first call to <a class="el" href="group___c_a_r_t.html#ga07eb1757b968c01796e32a5b9350cb8f">crt_context_create()</a>. </dd></dl>

</div>
</div>
<a id="gadae1ac0327dd9ad5049299bc4f565fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadae1ac0327dd9ad5049299bc4f565fb0">&#9670;&nbsp;</a></span>crt_group_auto_rank_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_group_auto_rank_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrt__group.html">crt_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable auto-rank removal on secondary group. Only applicable for primary groups.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grp</td><td>Group handle</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>Flag to enable or disable the option</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value on failure. </dd></dl>

</div>
</div>
<a id="ga488d62a433d3799355798075a9d2aa25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga488d62a433d3799355798075a9d2aa25">&#9670;&nbsp;</a></span>crt_group_config_path_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_group_config_path_set </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set an alternative directory to store/retrieve group attach info</p>
<p>The default location is /tmp. This allows client and server to agree on a location where to store the information and to avoid conflicts with other server groups that may be sharing the nodes</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path where to store attach info</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="ga1fecd36a0cebf97f4a1dd8ad7fc17f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fecd36a0cebf97f4a1dd8ad7fc17f70">&#9670;&nbsp;</a></span>crt_group_config_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_group_config_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrt__group.html">crt_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove the attach info file for the specified group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grp</td><td>Primary service group attach info to delete, NULL indicates local primary group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value on error </dd></dl>

</div>
</div>
<a id="ga4524b67a753babb8236aa5628e46b273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4524b67a753babb8236aa5628e46b273">&#9670;&nbsp;</a></span>crt_group_config_save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_group_config_save </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrt__group.html">crt_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forall</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump the attach info for the specified group to a file. If not the local primary service group, it must be an attached service group. This must be invoked before any singleton can attach to the specified group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grp</td><td>Primary service group attach info to save, NULL indicates local primary group. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forall</td><td>True to save all service ranks' uri addresses, false to only save the calling rank's uri for server, or the internal PSR of attached remote service group for client.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="ga89eb388dcb9f8e29d4aaa3f10aec0dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89eb388dcb9f8e29d4aaa3f10aec0dd8">&#9670;&nbsp;</a></span>crt_group_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_group_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrt__group.html">crt_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">crt_grp_destroy_cb_t&#160;</td>
          <td class="paramname"><em>grp_destroy_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy a CRT group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grp</td><td>group handle to be destroyed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grp_destroy_cb</td><td>optional completion callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>optional arg for <em>grp_destroy_cb</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="ga25fd9e4aeddc993b950f4f6d1b1cc5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25fd9e4aeddc993b950f4f6d1b1cc5e6">&#9670;&nbsp;</a></span>crt_group_detach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_group_detach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrt__group.html">crt_group_t</a> *&#160;</td>
          <td class="paramname"><em>attached_grp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Detach a primary service group which was attached previously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">attached_grp</td><td>attached primary service group handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="gafcba15a416034cca857d610726be3d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcba15a416034cca857d610726be3d7b">&#9670;&nbsp;</a></span>crt_group_info_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_group_info_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrt__group.html">crt_group_t</a> *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_iov_t *&#160;</td>
          <td class="paramname"><em>grp_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve group information containing ranks and associated uris</p>
<p>This call will allocate memory for buffers in passed <em>grp_info</em>. User is responsible for freeing the memory once not needed anymore.</p>
<p>Returned data in <em>grp_info</em> can be passed to crt_group_info_set call in order to setup group on a different node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Group identifier </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grp_info</td><td>group info to be filled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value on failure. </dd></dl>

</div>
</div>
<a id="gad03bd00dfb94ae9df11d9b6d70297821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad03bd00dfb94ae9df11d9b6d70297821">&#9670;&nbsp;</a></span>crt_group_info_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_group_info_set </td>
          <td>(</td>
          <td class="paramtype">d_iov_t *&#160;</td>
          <td class="paramname"><em>grp_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets group info (nodes and associated uris) baesd on passed grp_info data. <em>grp_info</em> is to be retrieved via <em>crt_group_info_get</em> call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grp_info</td><td>Group information to set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value on failure. </dd></dl>

</div>
</div>
<a id="ga924c5e73f8133fadc6d323eb7ec596ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga924c5e73f8133fadc6d323eb7ec596ac">&#9670;&nbsp;</a></span>crt_group_lookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcrt__group.html">crt_group_t</a>* crt_group_lookup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gade68a0764f3116705808a124b9147ab6">crt_group_id_t</a>&#160;</td>
          <td class="paramname"><em>grp_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lookup the group handle of one group ID (sub-group or primary group).</p>
<p>The primary group can be queried using the group ID passed to crt_init. Some special cases: 1) If (grp_id == NULL), it means the default primary group ID CRT_DEFAULT_GRPID.</p>
<dl class="section note"><dt>Note</dt><dd>user can cache the returned group handle to avoid the overhead of frequent lookup.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grp_id</td><td>unique group ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>group handle on success, NULL if not found. </dd></dl>

</div>
</div>
<a id="gaa18493edb4133011d65bbae0176da16b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa18493edb4133011d65bbae0176da16b">&#9670;&nbsp;</a></span>crt_group_primary_modify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_group_primary_modify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrt__group.html">crt_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a> *&#160;</td>
          <td class="paramname"><em>ctxs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_ctxs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_rank_list_t *&#160;</td>
          <td class="paramname"><em>ranks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>uris</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga45d6c2aa7ad84115a6398b74d29150e5">crt_group_mod_op_t</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a primary group modification in an atomic fashion based on the operation specified. Currently supported operations are 'add', 'remove' and 'replace'. This API allows multiple ranks to be added or removed at the same time with a single call.</p>
<p>Add: Ranks in the rank list are added to the group with corresponding uris Remove: Ranks in the rank list are removed from the group Replace: Ranks that exist in group and not in rank list get removed Ranks that exist in rank list and not in group get added Ranks that exist in both rank list and group are left unmodified</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grp</td><td>Group handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctxs</td><td>Array of contexts </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_ctxs</td><td>Number of contexts </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ranks</td><td>Modification rank list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uris</td><td>Array of URIs corresponding to contexts and rank list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>Modification operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">version</td><td>New group version</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value on failure.</dd></dl>
<p>Note: uris shall be an array of (ranks-&gt;rl_nr * num_ctxs) strings In multi-provider case, where num_ctxs &gt; 1, uris array should be formed as follows: [uri0 for provider0 identified by ctx0] [uri1 for provider0] .... [uriX for provider0]</p>
<p>[uri0 for provider1 identified by ctx1] [uri1 for provider1] ... [uriX for provider1]</p>
<p>[uri0 for provider2 identified by ctx2] etc... </p>

</div>
</div>
<a id="ga5849954786bca2e5668a51f10641851a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5849954786bca2e5668a51f10641851a">&#9670;&nbsp;</a></span>crt_group_primary_rank_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_group_primary_rank_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a>&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcrt__group.html">crt_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_rank_t&#160;</td>
          <td class="paramname"><em>primary_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>uri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add rank to the specified primary group.</p>
<p>Passed ctx will be used to determine a provider for which the uri is being added in the case of the primary group.</p>
<p>For primary groups when uri is specified, the uri is assumed to be 'base' URI, corresponding to tag=0 of the node being added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Associated cart context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grp</td><td>Group handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">primary_rank</td><td>Primary rank to be added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uri</td><td>URI of the primary rank</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value on failure. </dd></dl>

</div>
</div>
<a id="ga18ffa8213adb6c0df49fb917b32087a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18ffa8213adb6c0df49fb917b32087a7">&#9670;&nbsp;</a></span>crt_group_psr_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_group_psr_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrt__group.html">crt_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_rank_t&#160;</td>
          <td class="paramname"><em>rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specify rank to be a PSR for the provided group</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grp</td><td>Group handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rank</td><td>Rank to set as PSR</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value on failure. </dd></dl>

</div>
</div>
<a id="ga9f31926b084149cfbe4ba581075a23e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f31926b084149cfbe4ba581075a23e3">&#9670;&nbsp;</a></span>crt_group_psrs_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_group_psrs_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrt__group.html">crt_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_rank_list_t *&#160;</td>
          <td class="paramname"><em>rank_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specify list of ranks to be a PSRs for the provided group</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grp</td><td>Group handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rank_list</td><td>Ranks to set as PSRs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value on failure. </dd></dl>

</div>
</div>
<a id="gaa6195cef16a9b1d8fcd53c6a70f698bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6195cef16a9b1d8fcd53c6a70f698bc">&#9670;&nbsp;</a></span>crt_group_rank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_group_rank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrt__group.html">crt_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_rank_t *&#160;</td>
          <td class="paramname"><em>rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query the caller's rank number within group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grp</td><td>CRT group handle, NULL mean the primary/global group </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rank</td><td>result rank number. In singleton mode always get rank 0 for local group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="ga38f94d125e012d5ee8c7e7e1951977f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38f94d125e012d5ee8c7e7e1951977f7">&#9670;&nbsp;</a></span>crt_group_rank_p2s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_group_rank_p2s </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrt__group.html">crt_group_t</a> *&#160;</td>
          <td class="paramname"><em>subgrp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_rank_t&#160;</td>
          <td class="paramname"><em>rank_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_rank_t *&#160;</td>
          <td class="paramname"><em>rank_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a primary group rank to a local subgroup rank. Given a primary group rank <code>rank_in</code>, find its rank number <code>rank_out</code> within a sub-group <code>subgrp</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subgrp</td><td>CRT subgroup handle. subgrp must be local, i.e. not created by <a class="el" href="group___c_a_r_t.html#ga69f78261760cc22432b6d79f591ef6f6">crt_group_attach()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rank_in</td><td>primary group rank number. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rank_out</td><td>the result rank number of the conversion. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4f8f6d935bf918c31003c82cc02bd55b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f8f6d935bf918c31003c82cc02bd55b">&#9670;&nbsp;</a></span>crt_group_rank_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_group_rank_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrt__group.html">crt_group_t</a> *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_rank_t&#160;</td>
          <td class="paramname"><em>rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove specified rank from the group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Group identifier </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rank</td><td>Rank to remove</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value on failure. </dd></dl>

</div>
</div>
<a id="ga1ee5768a3251446b9032a2efa9e82956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ee5768a3251446b9032a2efa9e82956">&#9670;&nbsp;</a></span>crt_group_rank_s2p()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_group_rank_s2p </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrt__group.html">crt_group_t</a> *&#160;</td>
          <td class="paramname"><em>subgrp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_rank_t&#160;</td>
          <td class="paramname"><em>rank_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_rank_t *&#160;</td>
          <td class="paramname"><em>rank_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a local subgroup rank to a primary group rank. Given a sub-group <code>subgrp</code> and rank <code>rank_in</code> within the sub-group, find out its primary group rank number <code>rank_out</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subgrp</td><td>CRT subgroup handle. subgrp must be local, i.e. not created by <a class="el" href="group___c_a_r_t.html#ga69f78261760cc22432b6d79f591ef6f6">crt_group_attach()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rank_in</td><td>rank number within grp. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rank_out</td><td>the result rank number of the conversion. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga404d78b73d711f7de5d997676fea00b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga404d78b73d711f7de5d997676fea00b5">&#9670;&nbsp;</a></span>crt_group_ranks_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_group_ranks_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrt__group.html">crt_group_t</a> *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_rank_list_t **&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve list of ranks that belong to the specified gorup.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Group identifier </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">list</td><td>Rank list that gets filled with members</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value on failure </dd></dl>

</div>
</div>
<a id="gafd785115d57a80cb730db77abb373b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd785115d57a80cb730db77abb373b16">&#9670;&nbsp;</a></span>crt_group_secondary_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_group_secondary_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gade68a0764f3116705808a124b9147ab6">crt_group_id_t</a>&#160;</td>
          <td class="paramname"><em>grp_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcrt__group.html">crt_group_t</a> *&#160;</td>
          <td class="paramname"><em>primary_grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_rank_list_t *&#160;</td>
          <td class="paramname"><em>ranks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcrt__group.html">crt_group_t</a> **&#160;</td>
          <td class="paramname"><em>ret_grp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a secondary group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grp_name</td><td>Name of the group </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">primary_grp</td><td>Primary group handle associated with this group. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ranks</td><td>Optional list of primary ranks </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret_grp</td><td>Returned group handle for the secondary group</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value on failure. </dd></dl>

</div>
</div>
<a id="ga1f780239bb28215e64aa3edb7e36021a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f780239bb28215e64aa3edb7e36021a">&#9670;&nbsp;</a></span>crt_group_secondary_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_group_secondary_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrt__group.html">crt_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy a secondary group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grp</td><td>Group handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value on failure. </dd></dl>

</div>
</div>
<a id="ga5a8c919b8f0d85264425e45311205b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a8c919b8f0d85264425e45311205b70">&#9670;&nbsp;</a></span>crt_group_secondary_modify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_group_secondary_modify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrt__group.html">crt_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_rank_list_t *&#160;</td>
          <td class="paramname"><em>sec_ranks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_rank_list_t *&#160;</td>
          <td class="paramname"><em>prim_ranks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga45d6c2aa7ad84115a6398b74d29150e5">crt_group_mod_op_t</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a secondary group modification in an atomic fashion based on the operation type specified. Operations are the same as in <a class="el" href="group___c_a_r_t.html#gaa18493edb4133011d65bbae0176da16b">crt_group_primary_modify</a> API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grp</td><td>Group handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sec_ranks</td><td>List of secondary ranks </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prim_ranks</td><td>List of primary ranks </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>Modification operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">version</td><td>New group version</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value on failure. </dd></dl>

</div>
</div>
<a id="ga6763a139366b59f7181c797fc40cd9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6763a139366b59f7181c797fc40cd9d6">&#9670;&nbsp;</a></span>crt_group_secondary_rank_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_group_secondary_rank_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrt__group.html">crt_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_rank_t&#160;</td>
          <td class="paramname"><em>secondary_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_rank_t&#160;</td>
          <td class="paramname"><em>primary_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add rank to the specified secondary group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grp</td><td>Group handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondary_rank</td><td>Secondary rank </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">primary_rank</td><td>Primary rank to map to secondary</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value on failure. </dd></dl>

</div>
</div>
<a id="ga3871193c4165b6dff00addb4836fc2a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3871193c4165b6dff00addb4836fc2a6">&#9670;&nbsp;</a></span>crt_group_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_group_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrt__group.html">crt_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query number of group members.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grp</td><td>CRT group handle, NULL mean the local primary/global group </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>size (total number of ranks) of the group. In singleton mode always get size 1 for local group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="gaeb3e7ce396595c4ccc7efd906fe0fc1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb3e7ce396595c4ccc7efd906fe0fc1f">&#9670;&nbsp;</a></span>crt_group_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_group_version </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrt__group.html">crt_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query the group membership version</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grp</td><td>CRT group handle, NULL means the local primary/global group </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">version</td><td>group membership version</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value on error </dd></dl>

</div>
</div>
<a id="ga551bfde3b82cd593538596880b820e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga551bfde3b82cd593538596880b820e46">&#9670;&nbsp;</a></span>crt_group_version_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_group_version_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrt__group.html">crt_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the group membership version</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grp</td><td>CRT group handle, NULL means the local primary/global group </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">version</td><td>New group membership version</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value on error </dd></dl>

</div>
</div>
<a id="ga276c01c89aa5db8c3cdd1fd12fa6cde0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga276c01c89aa5db8c3cdd1fd12fa6cde0">&#9670;&nbsp;</a></span>crt_group_view_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_group_view_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gade68a0764f3116705808a124b9147ab6">crt_group_id_t</a>&#160;</td>
          <td class="paramname"><em>grpid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcrt__group.html">crt_group_t</a> **&#160;</td>
          <td class="paramname"><em>ret_grp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create local group view and return a handle to a group. This call is only supported for clients.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grp_id</td><td>Group id to create </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret_grp</td><td>Returned group handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value on failure </dd></dl>

</div>
</div>
<a id="ga9d2535be2fa010039ae73222af0c603b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d2535be2fa010039ae73222af0c603b">&#9670;&nbsp;</a></span>crt_group_view_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_group_view_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrt__group.html">crt_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy group handle previously created by <em>crt_Group_view_create</em> This call is only supported for clients</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grp</td><td>Group handle to destroy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value on failure. </dd></dl>

</div>
</div>
<a id="ga41358b9de3b91a0f453077886b64ea22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41358b9de3b91a0f453077886b64ea22">&#9670;&nbsp;</a></span>crt_hlc2nsec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t crt_hlc2nsec </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>hlc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the nanosecond timestamp of hlc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hlc</td><td>HLC timestamp</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nanosecond timestamp </dd></dl>

</div>
</div>
<a id="ga0dcbf9c1b804b281539c8d14884e9f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0dcbf9c1b804b281539c8d14884e9f2e">&#9670;&nbsp;</a></span>crt_hlc2unixnsec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t crt_hlc2unixnsec </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>hlc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the Unix nanosecond timestamp of hlc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hlc</td><td>HLC timestamp</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unix nanosecond timestamp </dd></dl>

</div>
</div>
<a id="ga154ce95ef86a6ded2d1470dbbbc87131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga154ce95ef86a6ded2d1470dbbbc87131">&#9670;&nbsp;</a></span>crt_hlc_epsilon_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t crt_hlc_epsilon_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the maximum system clock offset. See crt_hlc_set_epsilon's API doc.</p>
<dl class="section return"><dt>Returns</dt><dd>Nonnegative HLC duration </dd></dl>

</div>
</div>
<a id="gac6e9725c387d76d22a7f6b7a99d5d601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6e9725c387d76d22a7f6b7a99d5d601">&#9670;&nbsp;</a></span>crt_hlc_epsilon_get_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t crt_hlc_epsilon_get_bound </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>hlc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the upper bound of the HLC timestamp of an event happened before (through out of band communication) the event at <em>hlc</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hlc</td><td>HLC timestamp</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Upper bound HLC timestamp </dd></dl>

</div>
</div>
<a id="ga2737d6daf6a8ad986097ff85fc8736a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2737d6daf6a8ad986097ff85fc8736a6">&#9670;&nbsp;</a></span>crt_hlc_epsilon_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crt_hlc_epsilon_set </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>epsilon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the maximum system clock offset.</p>
<p>This is the maximum offset believed to be observable between the physical clocks behind any two HLCs in the system. The format of the value represent a nonnegative diff between two HLC timestamps. The value is rounded up to the HLC physical resolution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">epsilon</td><td>Nonnegative HLC duration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadfaee37eaf074ffaab7a7706544935c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfaee37eaf074ffaab7a7706544935c5">&#9670;&nbsp;</a></span>crt_hlc_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t crt_hlc_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return current HLC timestamp</p>
<p>HLC timestamps are synchronized between nodes. They sends with each RPC for different nodes and updated when received from different node. The HLC timestamps synchronization will be called transparently at sending/receiving RPC into the wire (when Mercury will encode/decode the packet). So, with each call of this function you will get from it always last HLC timestamp synchronized across all nodes involved in current communication.</p>
<dl class="section return"><dt>Returns</dt><dd>HLC timestamp </dd></dl>

</div>
</div>
<a id="ga25030f5bcea43a1e47f56cf7f43cd596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25030f5bcea43a1e47f56cf7f43cd596">&#9670;&nbsp;</a></span>crt_hlc_get_msg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_hlc_get_msg </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>hlc_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sync HLC with remote message and get current HLC timestamp.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>remote HLC timestamp </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hlc_out</td><td>HLC timestamp </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">offset</td><td>Returned observed clock offset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success or error on failure </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-DER_HLC_SYNC</td><td><em>msg</em> is too much higher than the local physical clock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9383ec65a20b8de170a7e54c19ed135d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9383ec65a20b8de170a7e54c19ed135d">&#9670;&nbsp;</a></span>crt_init_opt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_init_opt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gade68a0764f3116705808a124b9147ab6">crt_group_id_t</a>&#160;</td>
          <td class="paramname"><em>grpid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gab22231966be5442b49fdced962a513df">crt_init_options_t</a> *&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize CRT transport layer. Must be called on both the server side and the client side. This function is reference counted, it can be called multiple times. Each call must be paired with a corresponding <a class="el" href="group___c_a_r_t.html#gac4586b6542b4c809a737a63e18b6f314">crt_finalize()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grpid</td><td>primary group ID, user can provide a NULL value in that case will use the default group ID CRT_DEFAULT_GRPID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>bit flags, see <a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaad03f467ebc70e6873998feeaa0a9dae">crt_init_flag_bits</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opt</td><td>additional init time options. If a NULL value is provided, this call becomes identical to crt_init().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="ga4a895b8ea1fb5065547e963872a6ad5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a895b8ea1fb5065547e963872a6ad5f">&#9670;&nbsp;</a></span>crt_nsec2hlc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t crt_nsec2hlc </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>nsec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the HLC timestamp from nsec.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nsec</td><td>Nanosecond timestamp</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HLC timestamp </dd></dl>

</div>
</div>
<a id="gaf7e7c9babd4f43f0a1ae0b96f1702c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7e7c9babd4f43f0a1ae0b96f1702c7d">&#9670;&nbsp;</a></span>crt_proc_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_proc_bool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a>&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic processing routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">proc</td><td>abstract processor object </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>pointer to data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="ga452dc384be3595f6d7bd286b86e61230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga452dc384be3595f6d7bd286b86e61230">&#9670;&nbsp;</a></span>crt_proc_crt_bulk_t()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_proc_crt_bulk_t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a>&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga98854df58311faf6d4fcfb3c7554f66c">crt_bulk_t</a> *&#160;</td>
          <td class="paramname"><em>bulk_hdl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic processing routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">proc</td><td>abstract processor object </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bulk_hdl</td><td>pointer to bulk handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="gae16aeb42e71f6607342c8a3d86a65367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae16aeb42e71f6607342c8a3d86a65367">&#9670;&nbsp;</a></span>crt_proc_d_const_string_t()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_proc_d_const_string_t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a>&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_const_string_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic processing routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">proc</td><td>abstract processor object </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>pointer to data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="gab8e5dddce30fb7643832ed05304e3d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8e5dddce30fb7643832ed05304e3d5a">&#9670;&nbsp;</a></span>crt_proc_d_iov_t()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_proc_d_iov_t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a>&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_iov_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic processing routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">proc</td><td>abstract processor object </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>pointer to data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="ga2ae2e6bf75b5f8b89b996d69ef98dc1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ae2e6bf75b5f8b89b996d69ef98dc1d">&#9670;&nbsp;</a></span>crt_proc_d_rank_list_t()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_proc_d_rank_list_t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a>&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_rank_list_t **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic processing routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">proc</td><td>abstract processor object </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>second level pointer to data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error</dd></dl>
<dl class="section note"><dt>Note</dt><dd>1) here pass in the 2nd level pointer of d_rank_list_t, to make it possible to set it to NULL when decoding. 2) if the rank_list is non-NULL, caller should firstly duplicate it and pass the duplicated rank list's 2nd level pointer as parameter, because this function will internally free the memory when freeing the input or output. </dd></dl>

</div>
</div>
<a id="ga778f5628eab28dfe9650d7a0ea189394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga778f5628eab28dfe9650d7a0ea189394">&#9670;&nbsp;</a></span>crt_proc_d_string_t()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_proc_d_string_t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a>&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_string_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic processing routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">proc</td><td>abstract processor object </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>pointer to data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="ga822752e99a7283692cd060fab6e1daee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga822752e99a7283692cd060fab6e1daee">&#9670;&nbsp;</a></span>crt_proc_get_op()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_proc_get_op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a>&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t.html#gacfbc8243090b9821fcb4a138a205cb34">crt_proc_op_t</a> *&#160;</td>
          <td class="paramname"><em>proc_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the operation type associated to the proc processor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">proc</td><td>abstract processor object </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">proc_op</td><td>returned proc operation type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="ga2ed12b03a85fba73bda6054fd6f53f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ed12b03a85fba73bda6054fd6f53f20">&#9670;&nbsp;</a></span>crt_proc_int16_t()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_proc_int16_t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a>&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic processing routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">proc</td><td>abstract processor object </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>pointer to data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="gaa95f26166658b049482d10e6fee8ff28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa95f26166658b049482d10e6fee8ff28">&#9670;&nbsp;</a></span>crt_proc_int32_t()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_proc_int32_t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a>&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic processing routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">proc</td><td>abstract processor object </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>pointer to data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="ga6ff49fb8d9573d4f1d48c5262d5664e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ff49fb8d9573d4f1d48c5262d5664e7">&#9670;&nbsp;</a></span>crt_proc_int64_t()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_proc_int64_t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a>&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic processing routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">proc</td><td>abstract processor object </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>pointer to data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="ga4ef07373df253f6c70ef1e1e45d322b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ef07373df253f6c70ef1e1e45d322b8">&#9670;&nbsp;</a></span>crt_proc_int8_t()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_proc_int8_t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a>&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic processing routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">proc</td><td>abstract processor object </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>pointer to data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="gac68d7ff7120655c800ba09359640be50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac68d7ff7120655c800ba09359640be50">&#9670;&nbsp;</a></span>crt_proc_memcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_proc_memcpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a>&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Base proc routine using memcpy().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">proc</td><td>abstract processor object </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>pointer to data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>data size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="ga7b00ae9657ee806e0859e2a631987a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b00ae9657ee806e0859e2a631987a94">&#9670;&nbsp;</a></span>crt_proc_uint16_t()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_proc_uint16_t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a>&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic processing routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">proc</td><td>abstract processor object </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>pointer to data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="ga26a21f8d43858142c598eee1387b12b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26a21f8d43858142c598eee1387b12b7">&#9670;&nbsp;</a></span>crt_proc_uint32_t()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_proc_uint32_t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a>&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic processing routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">proc</td><td>abstract processor object </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>pointer to data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="ga7c220deeb56ef025dcbd69d6ca9d70d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c220deeb56ef025dcbd69d6ca9d70d4">&#9670;&nbsp;</a></span>crt_proc_uint64_t()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_proc_uint64_t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a>&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic processing routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">proc</td><td>abstract processor object </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>pointer to data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="ga91b123e3fa2287bd0a31ebf8cbc2a4f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91b123e3fa2287bd0a31ebf8cbc2a4f0">&#9670;&nbsp;</a></span>crt_proc_uint8_t()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_proc_uint8_t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a>&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic processing routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">proc</td><td>abstract processor object </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>pointer to data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="ga4703edbf21168a660b18b993917878d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4703edbf21168a660b18b993917878d8">&#9670;&nbsp;</a></span>crt_proc_uuid_t()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_proc_uuid_t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a>&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uuid_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic processing routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">proc</td><td>abstract processor object </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>pointer to data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="gad8e2ce33333c631754c0ea69846851d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8e2ce33333c631754c0ea69846851d8">&#9670;&nbsp;</a></span>crt_progress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_progress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a>&#160;</td>
          <td class="paramname"><em>crt_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Progress RPC execution on a cart context <em>crt_ctx</em> for at most <em>timeout</em> micro-seconds. The progress call returns when the timeout is reached or any completion has occurred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">crt_ctx</td><td>cart context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>how long is caller going to wait (micro-second) at most for a completion to occur. Can return when one or more operation progressed. zero means no waiting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success -DER_TIMEDOUT if exited after timeout has expired negative value if other internal error </dd></dl>

</div>
</div>
<a id="gab7611702682ff56c57d697cb2670d426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7611702682ff56c57d697cb2670d426">&#9670;&nbsp;</a></span>crt_progress_cond()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_progress_cond </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a>&#160;</td>
          <td class="paramname"><em>crt_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gacef78a24d5f55f2da8a57bb1aceef174">crt_progress_cond_cb_t</a>&#160;</td>
          <td class="paramname"><em>cond_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Progress RPC execution on a cart context with a callback function. The callback function is regularly called internally. The progress call returns when the callback returns a non-zero value or when the timeout expires.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">crt_ctx</td><td>cart context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>how long is the caller going to wait in micro-second. zero means no waiting and -1 waits indefinitely. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cond_cb</td><td>progress condition callback. cart internally calls this function, when it returns non-zero then stops the progressing or waiting and returns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>optional argument to cond_cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success -DER_TIMEDOUT if exited after timeout has expired negative value if internal and <em>conb_cb</em> error </dd></dl>

</div>
</div>
<a id="gafe86d4600a2c1c1755c808b2834e7aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe86d4600a2c1c1755c808b2834e7aa4">&#9670;&nbsp;</a></span>crt_proto_query()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_proto_query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrt__endpoint__t.html">crt_endpoint_t</a> *&#160;</td>
          <td class="paramname"><em>tgt_ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gae3dde8d6f8414e344befaafc0a3b7d3a">crt_opcode_t</a>&#160;</td>
          <td class="paramname"><em>base_opc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>ver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gac91077f0afeb8cf8f6dc6933d7e54a6b">crt_proto_query_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>query tgt_ep if it has registered base_opc with version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tgt_ep</td><td>the service rank to query </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base_opc</td><td>the base opcode for the protocol </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ver</td><td>array of protocol version </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of elements in ver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>completion callback. <a class="el" href="group___c_a_r_t.html#gafe86d4600a2c1c1755c808b2834e7aa4">crt_proto_query()</a> internally sends an RPC to <em>tgt_ep</em>. <em>cb</em> will be called upon completion of that RPC. The highest protocol version supported by the target is available to <em>cb</em> as cb_info-&gt;pq_ver. (See <a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gac91077f0afeb8cf8f6dc6933d7e54a6b">crt_proto_query_cb_t</a> and <a class="el" href="structcrt__proto__query__cb__info.html">crt_proto_query_cb_info</a>) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">arg</td><td>argument for <em>cb</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value on failure. </dd></dl>

</div>
</div>
<a id="gadfdd482f95145207f5e591af771037a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfdd482f95145207f5e591af771037a2">&#9670;&nbsp;</a></span>crt_proto_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_proto_register </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcrt__proto__format.html">crt_proto_format</a> *&#160;</td>
          <td class="paramname"><em>cpf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A protocol is a set of RPCs. A protocol has a base opcode and a version, member RPCs have opcodes that are contiguous numbers starting from (base opcode | version). For example, if the protocol has</p>
<p>base opcode: 0x05000000 version number: 0x00030000,</p>
<p>its member RPCs will have opcode 0x05030000 0x05030001 0x05030002 and so on</p>
<p>base opcode mask 0xFF000000UL version number mask 0x00FF0000UL</p>
<p>The base opcode 0xFF000000UL is not allowed. This gives 255 protocols, 256 versions for each protocol, 65,536 RPCs per protocol.</p>
<p>Mode of operation:</p>
<p>The client and server have knowledge of all possibly supported protocols. The protocol negotiation is just to let a client find out which ones are actually registered on the server.</p>
<p>1) A server registers a protocol with base opcode MY_BASE_OPC and version number MY_VER, with member RPC opcodes MY_OPC_0 = (MY_BASE_OPC | MY_VER), MY_OPC_1 = (MY_BASE_OPC | MY_VER) + 1, MY_OPC_2 = (MY_BASE_OPC | MY_VER) + 2, 2) A client queries the server if MY_BASE_OPC with version number is registered, the server replies Yes.</p>
<p>3) The client registers MY_BASE_OPC with version number MY_VER, then starts sending RPCs using it's member opcodes. 1) define crf for each member RPC. my_rpc_crf_1, my_rpc_crf_2</p>
<p>2) req_format array for member RPCs: struct <a class="el" href="structcrt__req__format.html">crt_req_format</a> *my_crf_array[] = { &amp;my_crf_1, &amp;my_crf_2, };</p>
<p>rpc handler array for member RPCs, one handler for each RPC: crt_rpc_cb_t hdlr[] = { my_hdlr_1, my_hdlr_2, };</p>
<p>3) define <a class="el" href="structcrt__proto__format.html">crt_proto_format</a>. struct <a class="el" href="structcrt__proto__format.html">crt_proto_format</a> my_proto_fmt = DEFINE_CRT_PROTO_FMT("my-proto", ver, my_crf_array);</p>
<p>which expands to: { .cpf_name = "my-proto"; .cpf_ver = ver; .cpf_crf = { &amp;my_crf_1, &amp;my_crf_2, }; .cpf_hdlr = { my_hdlr_1, my_hdlr_2, }; } Register a protocol. Can be called on a server or a client. Re-registering existing base_opc + version combination will result in -DER_EXIST error being returned to the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cpf</td><td>protocol format description. (See <a class="el" href="structcrt__proto__format.html">crt_proto_format</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value on failure. </dd></dl>

</div>
</div>
<a id="ga896d0246d32f5e9edc4572fdd90fdf79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga896d0246d32f5e9edc4572fdd90fdf79">&#9670;&nbsp;</a></span>crt_rank_abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_rank_abort </td>
          <td>(</td>
          <td class="paramtype">d_rank_t&#160;</td>
          <td class="paramname"><em>rank</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Abort all in-flight RPC requests targeting rank</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rank</td><td>rank to cancel</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="ga076fbaa744c9de3126d40e67e32d44c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga076fbaa744c9de3126d40e67e32d44c4">&#9670;&nbsp;</a></span>crt_rank_abort_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_rank_abort_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrt__group.html">crt_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Abort all in-flight RPCs to all ranks in the group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grp</td><td>group to cancel in. NULL for default group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="ga57f75b8ebd9c694b07c3aae13b9365ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57f75b8ebd9c694b07c3aae13b9365ac">&#9670;&nbsp;</a></span>crt_rank_self_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_rank_self_set </td>
          <td>(</td>
          <td class="paramtype">d_rank_t&#160;</td>
          <td class="paramname"><em>rank</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set self rank.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rank</td><td>Rank to set on self.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value on failure. </dd></dl>

</div>
</div>
<a id="gac627ee6b4355ab3e277453a60ee0174d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac627ee6b4355ab3e277453a60ee0174d">&#9670;&nbsp;</a></span>crt_rank_state_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_rank_state_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrt__group.html">crt_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_rank_t&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structswim__member__state.html">swim_member_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get rank SWIM state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grp</td><td>Group identifier </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rank</td><td>Rank to get SWIM state for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">state</td><td>The pointer to store SWIM state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value on failure. </dd></dl>

</div>
</div>
<a id="gac61f182a8231c602267eafc5f1fc544f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac61f182a8231c602267eafc5f1fc544f">&#9670;&nbsp;</a></span>crt_rank_uri_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_rank_uri_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcrt__group.html">crt_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_rank_t&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>uri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve URI of the requested rank:tag pair.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grp</td><td>Group identifier </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rank</td><td>Rank to get uri for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Tag to get uri for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">uri</td><td>Returned uri string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Returned uri string must be de-allocated by the user at some point once the information is no longer needed.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value on failure. </dd></dl>

</div>
</div>
<a id="gaf65c8659f71470294c9d702b78a86097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf65c8659f71470294c9d702b78a86097">&#9670;&nbsp;</a></span>crt_register_event_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_register_event_cb </td>
          <td>(</td>
          <td class="paramtype">crt_event_cb&#160;</td>
          <td class="paramname"><em>event_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function registers an event handler for any changes in rank state. There is not any modification about the rank in rank list at this point. The decision about adding or eviction the rank should be made from an information from this handler.</p>
<p>Important: The event should be processed in non-blocking mode because this handler is called under lock which should not be held for long time. Sleeping is also prohibited in this handler! Only quick reaction is expected into this handler before return.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_handler</td><td>event handler to register </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>arg to event_handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value on error </dd></dl>

</div>
</div>
<a id="gabdc6b7a0637bd846543b97a89c3ef080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdc6b7a0637bd846543b97a89c3ef080">&#9670;&nbsp;</a></span>crt_register_progress_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_register_progress_cb </td>
          <td>(</td>
          <td class="paramtype">crt_progress_cb&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ctx_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a callback function which will be called inside <a class="el" href="group___c_a_r_t.html#gad8e2ce33333c631754c0ea69846851d8">crt_progress()</a> </p>

</div>
</div>
<a id="ga3d7216bc7c9cf01c3ca3ce41a1d52783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d7216bc7c9cf01c3ca3ce41a1d52783">&#9670;&nbsp;</a></span>crt_reply_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_reply_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga22c4380156baf0663b9d7eee1ae65004">crt_rpc_t</a> *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send an RPC reply. Only to be called on the server side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>pointer to RPC request</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error</dd></dl>
<dl class="section note"><dt>Note</dt><dd>the crt_rpc_t is exported to user, caller should fill the <a class="el" href="structcrt__rpc.html#a52b8062393d06dfc797f0d0c88334d5e">crt_rpc_t::cr_output</a> before sending the RPC reply. See <a class="el" href="group___c_a_r_t.html#ga620993c739a94ff703d78ce92a630c56">crt_req_create</a>. </dd></dl>

</div>
</div>
<a id="ga3061431302513c2fc6b37b0844eebfb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3061431302513c2fc6b37b0844eebfb0">&#9670;&nbsp;</a></span>crt_req_abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_req_abort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga22c4380156baf0663b9d7eee1ae65004">crt_rpc_t</a> *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Abort an RPC request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>pointer to RPC request</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error If the RPC has been sent out by crt_req_send, the completion callback will be called with DER_CANCELED set to <a class="el" href="structcrt__cb__info.html#a768754b09b1a5ec20c1007bdbf5a6d9b">crt_cb_info::cci_rc</a> for a successful aborting. </dd></dl>

</div>
</div>
<a id="gac57bcd14a37730e582e8e883cec02a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac57bcd14a37730e582e8e883cec02a34">&#9670;&nbsp;</a></span>crt_req_addref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_req_addref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga22c4380156baf0663b9d7eee1ae65004">crt_rpc_t</a> *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add reference of the RPC request.</p>
<p>The typical usage is that user needs to do some asynchronous operations in RPC handler and does not want to block in RPC handler, then it can call this function to hold a reference and return. Later when that asynchronous operation is done, it can release the reference (See <a class="el" href="group___c_a_r_t.html#gadced98d9b4ff3084a36e4bc1034c28a8">crt_req_decref</a>). CRT internally frees the resource of the RPC request when its reference drops to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>pointer to RPC request</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="ga620993c739a94ff703d78ce92a630c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga620993c739a94ff703d78ce92a630c56">&#9670;&nbsp;</a></span>crt_req_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_req_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaf4e3a9a2fe312291fed2125c9971e54d">crt_context_t</a>&#160;</td>
          <td class="paramname"><em>crt_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcrt__endpoint__t.html">crt_endpoint_t</a> *&#160;</td>
          <td class="paramname"><em>tgt_ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gae3dde8d6f8414e344befaafc0a3b7d3a">crt_opcode_t</a>&#160;</td>
          <td class="paramname"><em>opc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga22c4380156baf0663b9d7eee1ae65004">crt_rpc_t</a> **&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an RPC request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">crt_ctx</td><td>CRT transport context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tgt_ep</td><td>RPC target endpoint </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opc</td><td>RPC request opcode </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">req</td><td>pointer to created request</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error</dd></dl>
<dl class="section note"><dt>Note</dt><dd>the crt_req_create will internally allocate zeroed buffers for input and output parameters (<a class="el" href="structcrt__rpc.html#a5062624e2652fd18e2007b41993cf2c1">crt_rpc_t::cr_input</a>/cr_output), and set the appropriate size (<a class="el" href="structcrt__rpc.html#a134c2b1b20464b06cbe2ffc221db00aa">crt_rpc_t::cr_input_size</a>/cr_output_size). User needs not to allocate extra input/output buffers. After the request created, user can directly fill input parameters into <a class="el" href="structcrt__rpc.html#a5062624e2652fd18e2007b41993cf2c1">crt_rpc_t::cr_input</a> and send the RPC request. When the RPC request finishes executing, CRT internally frees the RPC request and the input/output buffers, so user needs not to call crt_req_destroy (no such function exported) or free the input/output buffers. Similarly, on the RPC server-side, when an RPC request received, CRT internally allocates input/output buffers as well, and internally frees those buffers when the reply is sent out. So in user's RPC handler it needs not to allocate extra input/output buffers, and also needs not to free input/output buffers in the completion callback of crt_reply_send. tgt_ep may be NULL, in which case <a class="el" href="group___c_a_r_t.html#ga709043318d2a089cb7f8816afbb08388">crt_req_set_endpoint()</a> must be called for this req before <a class="el" href="group___c_a_r_t.html#gacfddf38953b180f44f8c4b53b9b57973">crt_req_send()</a>. </dd></dl>

</div>
</div>
<a id="gadced98d9b4ff3084a36e4bc1034c28a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadced98d9b4ff3084a36e4bc1034c28a8">&#9670;&nbsp;</a></span>crt_req_decref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_req_decref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga22c4380156baf0663b9d7eee1ae65004">crt_rpc_t</a> *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decrease reference of the RPC request. See <a class="el" href="group___c_a_r_t.html#gac57bcd14a37730e582e8e883cec02a34">crt_req_addref</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>pointer to RPC request</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="ga77c47e976ee1a7b340d32c7ad6ee76d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77c47e976ee1a7b340d32c7ad6ee76d3">&#9670;&nbsp;</a></span>crt_req_dst_rank_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_req_dst_rank_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga22c4380156baf0663b9d7eee1ae65004">crt_rpc_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_rank_t *&#160;</td>
          <td class="paramname"><em>rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return destination rank</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>Pointer to RPC request </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rank</td><td>Returned rank</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success or error on failure </dd></dl>

</div>
</div>
<a id="ga367a527b8653b020fedfcb6314dd623f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga367a527b8653b020fedfcb6314dd623f">&#9670;&nbsp;</a></span>crt_req_dst_tag_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_req_dst_tag_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga22c4380156baf0663b9d7eee1ae65004">crt_rpc_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return destination tag</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>Pointer to RPC request </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tag</td><td>Returned tag</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success or error on failure </dd></dl>

</div>
</div>
<a id="gacfddf38953b180f44f8c4b53b9b57973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfddf38953b180f44f8c4b53b9b57973">&#9670;&nbsp;</a></span>crt_req_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_req_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga22c4380156baf0663b9d7eee1ae65004">crt_rpc_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gaec5f68d3f953c61fadbd8a3d1a39c919">crt_cb_t</a>&#160;</td>
          <td class="paramname"><em>complete_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send an RPC request. In the case of sending failure, CRT internally destroy the request <em>req</em>. In the case of succeed, the <em>req</em> will be internally destroyed when the reply received. User needs not call <a class="el" href="group___c_a_r_t.html#gadced98d9b4ff3084a36e4bc1034c28a8">crt_req_decref()</a> to destroy the request in either case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>pointer to RPC request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">complete_cb</td><td>optional completion callback, when it is provided the completion result (success or failure) will be reported by calling it in the context of user's calling of <a class="el" href="group___c_a_r_t.html#gad8e2ce33333c631754c0ea69846851d8">crt_progress()</a> or <a class="el" href="group___c_a_r_t.html#gacfddf38953b180f44f8c4b53b9b57973">crt_req_send()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>arguments for the <em>complete_cb</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if <em>complete_cb</em> provided (non-NULL), always returns zero; otherwise returns DER_SUCCESS on success, negative value if error.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>the crt_rpc_t is exported to user, caller should fill the <a class="el" href="structcrt__rpc.html#a5062624e2652fd18e2007b41993cf2c1">crt_rpc_t::cr_input</a> and before sending the RPC request. See <a class="el" href="group___c_a_r_t.html#ga620993c739a94ff703d78ce92a630c56">crt_req_create</a>. </dd></dl>

</div>
</div>
<a id="ga709043318d2a089cb7f8816afbb08388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga709043318d2a089cb7f8816afbb08388">&#9670;&nbsp;</a></span>crt_req_set_endpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_req_set_endpoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga22c4380156baf0663b9d7eee1ae65004">crt_rpc_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcrt__endpoint__t.html">crt_endpoint_t</a> *&#160;</td>
          <td class="paramname"><em>tgt_ep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the endpoint for an RPC request.</p>
<p>This is an optional function, it must be called before req_send() if an endpoint was not provided to <a class="el" href="group___c_a_r_t.html#ga620993c739a94ff703d78ce92a630c56">crt_req_create()</a> however it will fail if there is already an endpoint associated with the request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>pointer to RPC request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tgt_ep</td><td>RPC target endpoint</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="ga5613cf2c576e417c441f66416c0a816d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5613cf2c576e417c441f66416c0a816d">&#9670;&nbsp;</a></span>crt_req_set_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_req_set_timeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga22c4380156baf0663b9d7eee1ae65004">crt_rpc_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout_sec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the timeout value for an RPC request.</p>
<p>It is an optional function. If user does not call it, then will depend on CRT_TIMEOUT ENV as timeout value (see the CRT_TIMEOUT section in README.env). User can also explicitly set one RPC request's timeout value by calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>pointer to RPC request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_sec</td><td>timeout value in seconds. value of zero will be treated as invalid parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="ga9abd7828b2b604fb68c34f5a4cf9568f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9abd7828b2b604fb68c34f5a4cf9568f">&#9670;&nbsp;</a></span>crt_req_src_rank_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_req_src_rank_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga22c4380156baf0663b9d7eee1ae65004">crt_rpc_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">d_rank_t *&#160;</td>
          <td class="paramname"><em>rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return originator/source rank</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>Pointer to RPC request </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rank</td><td>Returned rank</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success or error on failure </dd></dl>

</div>
</div>
<a id="ga13f295ad36554f93feee03e6fd76f789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13f295ad36554f93feee03e6fd76f789">&#9670;&nbsp;</a></span>crt_rpc_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_rpc_register </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gae3dde8d6f8414e344befaafc0a3b7d3a">crt_opcode_t</a>&#160;</td>
          <td class="paramname"><em>opc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcrt__req__format.html">crt_req_format</a> *&#160;</td>
          <td class="paramname"><em>drf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dynamically register an RPC with features at client-side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">opc</td><td>unique opcode for the RPC </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>feature bits, now only supports CRT_RPC_FEAT_NO_REPLY - disables reply when set, re-enables reply when not set. CRT_RPC_FEAT_NO_TIMEOUT - if it's set, the elapsed time is reset to 0 on RPC timeout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">drf</td><td>pointer to the request format, which describe the request format and provide callback to pack/unpack each items in the request. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="ga836b16ede44ec086c47c6c0da5f3c67c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga836b16ede44ec086c47c6c0da5f3c67c">&#9670;&nbsp;</a></span>crt_rpc_srv_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_rpc_srv_register </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gae3dde8d6f8414e344befaafc0a3b7d3a">crt_opcode_t</a>&#160;</td>
          <td class="paramname"><em>opc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcrt__req__format.html">crt_req_format</a> *&#160;</td>
          <td class="paramname"><em>crf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_a_r_t___t_y_p_e_s.html#ga163a4cfb0f83c051338adb9a4c326eed">crt_rpc_cb_t</a>&#160;</td>
          <td class="paramname"><em>rpc_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dynamically register an RPC with features at server-side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">opc</td><td>unique opcode for the RPC </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>feature bits, now only supports <a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gafea9e969d4960a162107c90d47a50879">CRT_RPC_FEAT_NO_REPLY</a> - disables reply when set, re-enables reply when not set. <a class="el" href="group___c_a_r_t___t_y_p_e_s.html#gadd33883ad9d938ca364507c9d8b0cec7">CRT_RPC_FEAT_NO_TIMEOUT</a> - if it's set, the elapsed time is reset to 0 on RPC timeout </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">crf</td><td>pointer to the request format, which describe the request format and provide callback to pack/unpack each items in the request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rpc_handler</td><td>pointer to RPC handler which will be triggered when RPC request opcode associated with rpc_name is received. Will return -DER_INVAL if pass in NULL rpc_handler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value if error </dd></dl>

</div>
</div>
<a id="gad6b2b86a7bc35f74afebcbe1dac4ca87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6b2b86a7bc35f74afebcbe1dac4ca87">&#9670;&nbsp;</a></span>crt_self_uri_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_self_uri_get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>uri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve uri of self for the specified tag. The uri must be freed by the user using D_FREE().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Tag to get uri for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">uri</td><td>Returned uri string This is a NULL terminated string of size up to CRT_ADDR_STR_MAX_LEN (including the trailing NULL). Must be freed by the user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value on failure. </dd></dl>

</div>
</div>
<a id="ga6c54f3ae1017bc377f5824766c531a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c54f3ae1017bc377f5824766c531a01">&#9670;&nbsp;</a></span>crt_swim_fini()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crt_swim_fini </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finalize swim. </p>

</div>
</div>
<a id="ga3bab597f86d13a32ae1ed335f3eda7bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bab597f86d13a32ae1ed335f3eda7bd">&#9670;&nbsp;</a></span>crt_swim_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_swim_init </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>crt_ctx_idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize swim on the specified context index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">crt_ctx_idx</td><td>Context index to initialize swim on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value on failure. </dd></dl>

</div>
</div>
<a id="ga100933432920bca56a6c1f51e9b1d35d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga100933432920bca56a6c1f51e9b1d35d">&#9670;&nbsp;</a></span>crt_unixnsec2hlc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t crt_unixnsec2hlc </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>unixnsec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the HLC timestamp of unixnsec in hlc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">unixnsec</td><td>Unix nanosecond timestamp</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HLC timestamp on success, or 0 when it is impossible to convert unixnsec to hlc </dd></dl>

</div>
</div>
<a id="gae333d240708c08ccd38ecf9df8449c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae333d240708c08ccd38ecf9df8449c35">&#9670;&nbsp;</a></span>crt_unregister_event_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_unregister_event_cb </td>
          <td>(</td>
          <td class="paramtype">crt_event_cb&#160;</td>
          <td class="paramname"><em>event_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister an event handler. The pair of arguments (event_handler and arg) should be same as the ones provided during registration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_handler</td><td>event handler to register </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>arg to event_handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DER_SUCCESS on success, negative value on error </dd></dl>

</div>
</div>
<a id="gaa63036cdba68a597084fe7a11da4aea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa63036cdba68a597084fe7a11da4aea7">&#9670;&nbsp;</a></span>crt_unregister_progress_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crt_unregister_progress_cb </td>
          <td>(</td>
          <td class="paramtype">crt_progress_cb&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ctx_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function. The pair of arguments (ctx_idx and arg) should be same as the ones provided during registration. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="astructcrt__req__format_html"><div class="ttname"><a href="structcrt__req__format.html">crt_req_format</a></div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00165">types.h:165</a></div></div>
<div class="ttc" id="agroup___c_a_r_t___t_y_p_e_s_html_ga1266fedf6067dbd6400b70730468145a"><div class="ttname"><a href="group___c_a_r_t___t_y_p_e_s.html#ga1266fedf6067dbd6400b70730468145a">crt_proc_cb_t</a></div><div class="ttdeci">int(* crt_proc_cb_t)(crt_proc_t proc, void *data)</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00163">types.h:163</a></div></div>
<div class="ttc" id="agroup___c_a_r_t___t_y_p_e_s_html_ga433c0df9cb4242d917d16dd2bc56968a"><div class="ttname"><a href="group___c_a_r_t___t_y_p_e_s.html#ga433c0df9cb4242d917d16dd2bc56968a">crt_proc_t</a></div><div class="ttdeci">void * crt_proc_t</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00161">types.h:161</a></div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
